import os.path
import sys
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
import time
import socket
import selectors
import logging
from logging.handlers import RotatingFileHandler
import struct
from datetime import datetime
from threading import *
import queue

import numpy as np
import scipy.linalg.lapack
import scipy.optimize
from scipy.stats import qmc, norm, chi2
import pymoo.optimize
import pymoo.core.problem
from pymoo.algorithms.moo.nsga2 import NSGA2
import math

import matplotlib
matplotlib.use("TkAgg")

from mpl_toolkits.mplot3d import proj3d
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib.figure import Figure

# splosne konstante
BUF_LEN = 4096
MAX_LOGS = 100
VAR_DIGITS = 4

THREAD_MSG_POINT = 1
THREAD_MSG_RESULT = 2
THREAD_MSG_INFO = 3

# stanja master programa
STATE_REGISTER = 1  # prvo javljanje programu FaustoSlave (sporoci id za komunikacijo)
STATE_SET_IR_SETTINGS = 2  # doloci valovne dolzine, ki jih IR spremlja, ter parametre za ugotavljanje stabilnosti reakcije
STATE_DESIGN_NEW_EXPERIMENT = 3  # master program izbere nastavitve za naslednji eksperiment (sistematicno ali z optimizacijo)
STATE_INITIATE_NEW_EXPERIMENT = 4  # master sporoci slave programu nastavitve za izvedbo novega eksperimenta
STATE_CHECK_EXPERIMENT_STABILITY = 5  # master preverja, ali je reakcija stabilna (IR)
STATE_INITIATE_EXPERIMENT_ANALYSIS = 6  # master sporoci slave programu naj zacne z analizo (UPLC)
STATE_CHECK_EXPERIMENT_ANALYSIS = 7  # master preverja, ali je opravljena analiza reakcije (UPLC)
STATE_PAUSED_IN_INTERACTIVE_MODE = 8  # master caka uporabnika, da nadaljuje z eksperimenti
STATE_SERIES_OF_EXPERIMENTS_COMPLETED = 9  # master je zakljucil s serijo eksperimentov
STATE_EXIT_PROGRAM = 10  # uporabnik zeli zapreti master program

# kljucne besede v config datoteki
CONFIG_COMMAND_FILE_VER = "CONFIG_FILE_VER"
CONFIG_COMMAND_CSV_FOLDER = "CSV_FOLDER"
CONFIG_COMMAND_REACTOR_CONST = "REACTOR_CONST"
CONFIG_COMMAND_REACTOR_VAR = "REACTOR_VAR"
CONFIG_COMMAND_REACTOR_STABILIZATION_MIN_TIME = "REACTOR_STABILIZATION_MIN_TIME"
CONFIG_COMMAND_REACTOR_STABILIZATION_MAX_TIME = "REACTOR_STABILIZATION_MAX_TIME"
CONFIG_COMMAND_IR_PEAKS = "IR_PEAKS"
CONFIG_COMMAND_IR_SLOPE_MEASUREMENTS = "IR_SLOPE_MEASUREMENTS"
CONFIG_COMMAND_IR_SLOPE_THRESHOLD = "IR_SLOPE_THRESHOLD"
CONFIG_COMMAND_UPLC_RETENTION_TIME = "UPLC_RETENTION_TIME"
CONFIG_COMMAND_SLAVE_URL = "SLAVE_URL"
CONFIG_COMMAND_MASTER_PORT = "MASTER_PORT"
CONFIG_COMMAND_SLAVE_RESPONSE_TIMEOUT = "SLAVE_RESPONSE_TIMEOUT"
CONFIG_COMMAND_LOG_LEVEL = "LOG_LEVEL"
CONFIG_COMMAND_EXPERIMENT_STABILITY_CHECK_INTERVAL = "STABILITY_CHECK_INTERVAL"
CONFIG_COMMAND_EXPERIMENT_ANALYSIS_MAX_TIME = "EXPERIMENT_ANALYSIS_MAX_TIME"
CONFIG_COMMAND_OPTIMIZER = "OPTIMIZER"

CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_REACTOR_VAR = "OPTIMIZER_MAXIMIZE_REACTOR_VAR"
CONFIG_COMMAND_OPTIMIZER_MINIMIZE_REACTOR_VAR = "OPTIMIZER_MINIMIZE_REACTOR_VAR"

CONFIG_COMMAND_OPTIMIZER_MINIMIZE_UPLC_AREA = "OPTIMIZER_MINIMIZE_UPLC_AREA"
CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_AREA = "OPTIMIZER_MAXIMIZE_UPLC_AREA"
CONFIG_COMMAND_OPTIMIZER_MINIMIZE_UPLC_CONC = "OPTIMIZER_MINIMIZE_UPLC_CONC"
CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_CONC = "OPTIMIZER_MAXIMIZE_UPLC_CONC"
CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_SEL = "OPTIMIZER_MAXIMIZE_UPLC_SEL"
CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_PROD = "OPTIMIZER_MAXIMIZE_UPLC_PROD"

CONFIG_COMMAND_TSEMO_INITIAL_SAMPLES_PER_VAR = "TSEMO_INITIAL_SAMPLES_PER_VAR"
CONFIG_COMMAND_TSEMO_NUM_OF_ITERATIONS = "TSEMO_NUM_OF_ITERATIONS"
CONFIG_COMMAND_TSEMO_NUM_OF_SPECTRAL_SAMPLING_POINTS = "TSEMO_NUM_OF_SPECTRAL_SAMPLING_POINTS"
CONFIG_COMMAND_TSEMO_MATERN_CLASS = "TSEMO_MATERN_CLASS"
CONFIG_COMMAND_TSEMO_DIRECT_EVALS = "TSEMO_DIRECT_EVALS"
CONFIG_COMMAND_TSEMO_GA_POP_SIZE = "TSEMO_GA_POP_SIZE"
CONFIG_COMMAND_TSEMO_GA_NUM_OF_GENERATIONS = "TSEMO_GA_NUM_OF_GENERATIONS"
CONFIG_COMMAND_TSEMO_ITERATION_BATCH_SIZE = "TSEMO_ITERATION_BATCH_SIZE"
CONFIG_COMMAND_TSEMO_BACKUP_STEPS = "TSEMO_BACKUP_STEPS"

OPTIMIZER_TSEMO = "TSEMO"
OPTIMIZER_NONE = "NONE"

# privzete nastavitve
DEFAULT_MIN_STABILIZATION_TIME = 10
DEFAULT_MAX_STABILIZATION_TIME = 50
DEFAULT_MAX_EXPERIMENT_ANALYSIS_TIME = 3600
DEFAULT_SLAVE_RESPONSE_TIMEOUT = 5

DEFAULT_CSV_FOLDER = "C:\\FaustoIT\\Master\\"
DEFAULT_IR_SLOPE_MEASUREMENTS = 5
DEFAULT_IR_SLOPE_THRESHOLD = 5.0
DEFAULT_SLAVE_HOST = "127.0.0.1"
DEFAULT_SLAVE_PORT = 5000
DEFAULT_MASTER_PORT = 5001
DEFAULT_VERBOSE = 1
DEFAULT_EXPERIMENT_STABILITY_CHECK_INTERVAL = 10
DEFAULT_EXPERIMENT_ANALYSIS_CHECK_INTERVAL = 10
DEFAULT_OPTIMIZER = OPTIMIZER_NONE

# privzete nastavitve za TSEMO
DEFAULT_TSEMO_INITIAL_SAMPLES_PER_VAR = 5
DEFAULT_TSEMO_NUM_OF_ITERATIONS = 40
DEFAULT_TSEMO_NUM_OF_SPECTRAL_SAMPLING_POINTS = 4000
DEFAULT_TSEMO_MATERN_CLASS = 1
DEFAULT_TSEMO_DIRECT_EVALS = 200
DEFAULT_TSEMO_GA_POP_SIZE = 100
DEFAULT_TSEMO_GA_NUM_OF_GENERATIONS = 100
DEFAULT_TSEMO_ITERATION_BATCH_SIZE = 1
DEFAULT_TSEMO_BACKUP_STEPS = 2

# rezervirane vrednosti za komunikacijo FaustoMater-OptimizerThread

OPTIMIZATION_FINISHED = "OPT_FIN"



TEXT_INTERACTIVE = "Interaktivno"
TEXT_MAINTENANCE = "Zahtevaj servis"
TEXT_NEXT = "Naslednji"
TEXT_CONTINUE = "Nadaljuj"
TEXT_CLEAR = "Izbrisi"
TEXT_CURRENT_SETTINGS = "Trenutne nastavitve spremenljivk:"
TEXT_QUIT ="Konec"

###############################################################################
#
# POZOR! Kljucne besede protokola morajo biti enake kot v FaustoSlave32
#
###############################################################################

# ukazi za komunikacijo med FaustoMaster in FaustoSlave aplikacijo
PROTOCOL_COMMAND_REG = "REG"
PROTOCOL_COMMAND_SET_IR = "SIR"
PROTOCOL_COMMAND_SET_REACTOR_VARS = "SRV"
PROTOCOL_COMMAND_CHECK_STABILITY = "CHS"
PROTOCOL_COMMAND_START_ANALYSIS = "SAN"
PROTOCOL_COMMAND_CHECK_ANALYSIS = "CAN"

PROTOCOL_ATTR_PKS = "PKS"
PROTOCOL_ATTR_SM = "SM"
PROTOCOL_ATTR_ST = "ST"

PROTOCOL_RESULT_OK = "OK"
PROTOCOL_RESULT_YES = "YES"
PROTOCOL_RESULT_NO = "NO"
PROTOCOL_RESULT_SYNTAX_ERROR = "SER"
PROTOCOL_RESULT_EXEC_ERROR = "EER"
PROTOCOL_RESULT_PROTOCOL_ERROR = "PER"

#=============================================================================#

class Window(tk.Toplevel):
    def __init__(self, parent):
        super().__init__(parent)

        self.geometry('300x100')
        self.title('Toplevel Window')

        ttk.Button(self,
                text='Close',
                command=self.destroy).pack(expand=True)

##############################################################################################################
#
# Logger
#
##############################################################################################################

def get_master_logger():
    FORMATTER = logging.Formatter(fmt="%(asctime)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S")

    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(FORMATTER)

    file_handler = RotatingFileHandler("master.log", maxBytes=2000000, backupCount=5)
    file_handler.setFormatter(FORMATTER)

    logger = logging.getLogger("Master")
    logger.setLevel(logging.INFO)
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    logger.propagate = False
    return logger


##############################################################################################################
#
# Direct
#
##############################################################################################################

def calc_ubound(lengths, fc, hull, szes):
    hull_length = len(hull)
    hull_lengths = lengths[:, hull]
    ub = np.zeros(hull_length)
    for i in range(0, hull_length):
        tmp_rects = np.flatnonzero(np.sum(hull_lengths, 0) < np.sum(lengths[:, hull[i]]))
        if len(tmp_rects) > 0:
            tmp_f = fc[hull[tmp_rects]]
            tmp_szes = szes[hull[tmp_rects]]
            tmp_ubs = (tmp_f - fc[hull[i]]) / (tmp_szes-szes[hull[i]])
            ub[i] = np.min(tmp_ubs)
        else:
            ub[i] = 1.976e14
    return ub

def calc_lbound(lengths, fc, hull, szes):
    hull_length = len(hull)
    hull_lengths = lengths[:, hull]
    lb = np.zeros(hull_length)
    for i in range(0, hull_length):
        tmp_rects = np.flatnonzero(np.sum(hull_lengths, 0) > np.sum(lengths[:, hull[i]]))
        if len(tmp_rects) > 0:
            tmp_f = fc[hull[tmp_rects]]
            tmp_szes = szes[hull[tmp_rects]]
            tmp_lbs = (fc[hull[i]] - tmp_f) / (szes[hull[i]] - tmp_szes)
            lb[i] = np.min(tmp_lbs)
        else:
            lb[i] = -1.976e14
    return lb

def find_po(fc, lengths, minval, ep, szes):
    diff_szes = np.sum(lengths, 0)
    tmp_max = np.max(diff_szes).astype(int)
    sum_lengths = np.sum(lengths, 0)
    hull = np.array([], dtype=int)
    for i in range(0, tmp_max+1):
        tmp_idx = np.flatnonzero(sum_lengths == i)
        if len(tmp_idx) > 0:
            tmp_n = np.min(fc[tmp_idx])
            hullidx = np.argmin(fc[tmp_idx])
            hull = np.append(hull, tmp_idx[hullidx])
            ties = np.flatnonzero(np.abs(fc[tmp_idx]-tmp_n) <= 1e-13)
            if len(ties) > 1:
                mod_ties = np.flatnonzero(tmp_idx[ties] != hull[-1])
                if len(mod_ties) > 1:
                    hull = np.append(hull, tmp_idx[ties[mod_ties]])

    lbound = calc_lbound(lengths, fc, hull, szes)
    ubound = calc_ubound(lengths, fc, hull, szes)

    maybe_po = np.flatnonzero((lbound-ubound) <= 0)

    if minval != 0:
        po = np.flatnonzero((minval-fc[hull[maybe_po]]) / np.abs(minval) + szes[hull[maybe_po]] * ubound[maybe_po] / np.abs(minval) >= ep)
    else:
        po = np.flatnonzero(fc[hull[maybe_po]] - szes[hull[maybe_po]] * ubound[maybe_po] <= 0)

    final_pos = hull[maybe_po[po]]
    return final_pos

def CallObjFcn(Func, x, a, b, **kwargs):
    point = np.abs(b - a) * x + a
    fcn_value = Func(point, **kwargs)
    return fcn_value


def DIRini(Func, n, a, b, p_lengths, p_c, p_fc, p_szes, theglobalmin, maxdeep, tflag, **kwargs):
    l_lengths = p_lengths
    l_c = p_c
    l_fc = p_fc
    szes = p_szes

    l_thirds = np.zeros(maxdeep)
    l_thirds[0] = 1/3
    for i in range(1, maxdeep):
        l_thirds[i] = (1/3)*l_thirds[i-1]

    l_lengths[:, 0] = np.zeros(n)

    szes[0] = 1

    l_c[:, 0] = np.ones(n)/2

    l_fc[0] = CallObjFcn(Func, l_c[:, 0], a, b, **kwargs)
    fcncounter = 1


    xatmin = l_c[:, 0]
    minval = l_fc[0]
    if tflag == 1:
        if theglobalmin != 0:
            perror = 100 * (minval - theglobalmin) / np.abs(theglobalmin)
        else:
            perror = 100 * minval
    else:
        perror = 2

    return [l_thirds, l_lengths, l_c, l_fc, minval, xatmin, perror, szes, fcncounter]


def DIRdivide(a, b, Func, index, thirds, p_lengths, p_fc, p_c, p_fcncounter, p_szes, **kwargs):
    lengths = p_lengths
    fc = p_fc
    c = p_c
    szes = p_szes
    fcncounter = p_fcncounter

    li = lengths[:, index]
    biggy = np.min(li)
    ls = np.flatnonzero(li == biggy)
    lssize = len(ls)
    j = 0

    oldc = c[:, index]
    delta = thirds[biggy]
    newc_left = np.tile(oldc, [lssize,1]).transpose()
    newc_right = np.tile(oldc, [lssize,1]).transpose()
    f_left = np.zeros(lssize)
    f_right = np.zeros(lssize)

    for i in range(0,lssize):
        lsi = ls[i]
        newc_left[lsi, i] = newc_left[lsi, i] - delta
        newc_right[lsi, i] = newc_right[lsi, i] + delta
        f_left[i] = CallObjFcn(Func, newc_left[:, i], a, b, **kwargs)
        f_right[i] = CallObjFcn(Func, newc_right[:, i], a, b, **kwargs)
        fcncounter = fcncounter + 2

    w = np.transpose([np.min([f_left, f_right], 0), ls])
    order = np.argsort(w, 0)

    for i in range(0, np.shape(order)[0]):
        newleftindex  = p_fcncounter + 2*i
        newrightindex = p_fcncounter + 2*i + 1
        oldrect = lengths[:, index]
        lengths[:, newleftindex] = oldrect        # TODO: TUKAJ LAHKO GRE ZUNAJ MEJA POLJA
        lengths[:, newrightindex] = oldrect

        lengths[ls[order[i, 0]], newleftindex] = lengths[ls[order[i, 0]], index] + 1
        lengths[ls[order[i, 0]], newrightindex] = lengths[ls[order[i, 0]], index] + 1
        lengths[ls[order[i, 0]], index] = lengths[ls[order[i, 0]], index] + 1


        c[:, newleftindex] = newc_left[:, order[i, 0]]
        c[:, newrightindex] = newc_right[:, order[i, 0]]

        fc[newleftindex] = f_left[order[i, 0]]
        fc[newrightindex] = f_right[order[i, 0]]

        szes[newleftindex] = 1/2 * np.linalg.norm((1/3 * np.ones(np.shape(lengths)[0])) ** (lengths[:, newleftindex]), 2)
        szes[newrightindex] = 1/2 * np.linalg.norm((1/3 * np.ones(np.shape(lengths)[0])) ** (lengths[:, newrightindex]), 2)

    szes[index] = 1/2 * np.linalg.norm((1/3 * np.ones(np.shape(lengths)[0])) ** (lengths[:, index]), 2)

    return [lengths, fc, c, szes, fcncounter]



def Direct(Func, bounds, useropts=(), **kwargs):
    lengths = []
    c = []
    fc = []
    szes = []
    om_lower = bounds[:, 0]
    om_upper = bounds[:, 1]
    fcncounter = 0
    perror = 0
    itctr = 1
    done = 0
    n = bounds.shape[0]

    opts = {
        'maxits': 20,
        'maxevals': 10,
        'maxdeep': 100,
        'testflag': 0,
        'globalmin': 0,
        'ep': 1e-4,
        'tol': 0.01,
        'showits': 1,
        'pert': 1e-6
    }

    opts.update(useropts)

    theglobalmin = opts.get('globalmin')
    tflag = opts.get('testflag')
    maxits = opts.get('maxits')
    maxevals = opts.get('maxevals')
    tol = opts.get('tol')
    maxdeep = opts.get('maxdeep')
    showits = opts.get('showits')
    ep = opts.get('ep')

    if tflag == 0:
        lengths = np.zeros(shape=(n, maxevals + np.floor(0.10 * maxevals).astype(int))).astype(int)
        c = np.zeros(shape=(n, maxevals + np.floor(0.10 * maxevals).astype(int)))
        fc = np.zeros(maxevals + np.floor(0.10 * maxevals).astype(int))
        szes = np.zeros(maxevals + np.floor(0.10 * maxevals).astype(int))


    [thirds, lengths, c, fc, minval, xatmin, perror, szes, fcncounter] = DIRini(Func, n, bounds[:, 0], bounds[:, 1], lengths, c, fc, szes, theglobalmin, maxdeep, tflag, **kwargs)
    ret_minval = minval
    ret_xatmin = xatmin

    minval = fc[0]
    while perror > tol:
        S = find_po(fc[0:fcncounter], lengths[:, 0:fcncounter], minval, ep, szes[0: fcncounter])

        for i in range(0, len(S)):
            [lengths, fc, c, szes, fcncounter] = DIRdivide(bounds[:, 0], bounds[:, 1], Func, S[i], thirds, lengths, fc, c, fcncounter, szes, **kwargs)

        minval = np.min(fc[0:fcncounter])
        fminindex = np.argmin(fc[0:fcncounter])

        xatmin = (om_upper - om_lower) * c[:, fminindex] + om_lower

        ret_minval = minval
        ret_xatmin = xatmin

        if tflag == 1:
            if theglobalmin != 0:
                perror = 100 * (minval - theglobalmin) / np.abs(theglobalmin)
            else:
                perror = 100 * minval
        else:
            if itctr >= maxits:
                print('Exceeded max iterations. Increase maxits')
                done = 1

            if fcncounter > maxevals:
                done = 1

            if done == 1:
                perror = -1


        if np.max(np.max(lengths, 0)) >= maxdeep:
            print('Exceeded Max depth. Increse maxdeep')
            perror = -1

        if showits == 1:
            print('Iter: %4i   f_min: %15.10f    fn evals: %8i\n' % (itctr, minval, fcncounter))

        itctr = itctr + 1

    final_xatmin = ret_xatmin

    return [ret_minval, final_xatmin]


##############################################################################################################
#
# TSEMO
#
##############################################################################################################

def TSEMO_options(n):
    opt = {
        'maxeval': 35,
        'pop': 100,
        'Generation': 100,
        'NoOfBachSequential': 1,
        'GP': list()
    }

    for i in range(0, n):
        gp = {
            'nSpectralpoints': 4000,
            'matern': 1,
            'fun_eval': 200
        }
        opt['GP'].append(gp)

    return opt

def set_option_structure(Opt, X, Y):
    Opt['Gen'] = {
        'NoOfGPs': Y.shape[1],
        'NoOfInputDim': X.shape[1]
    }

    for i in range(0, Opt['Gen']['NoOfGPs']):
        Opt['GP'][i]['cov'] = Opt['GP'][i]['matern']
        Opt['GP'][i]['noiselimit'] = 0
        Opt['GP'][i]['var'] = 10
        Opt['GP'][i]['h1'] = Opt['Gen']['NoOfInputDim'] + 1
        Opt['GP'][i]['h2'] = 1
        Opt['GP'][i]['priorlik'] = (-6, Opt['GP'][i]['var'])
        Opt['GP'][i]['priorcov'] = (0, Opt['GP'][i]['var'])
        Opt['GP'][i]['hyp'] = {
            'cov': np.zeros(shape=(1, Opt['GP'][i]['h1'])),
            'lik': np.log(1e-2)
        }

    return Opt

def ScaleVariables(X, Y, lb, ub, Opt):
    constCol = None

    Xnew = np.zeros(shape=X.shape)  # scaled inputs
    Ynew = np.zeros(shape=Y.shape)

    for i in range(0, X.shape[1]):
        Xnew[:, i] = (X[:, i] - lb[i])/(ub[i] - lb[i])

    MeanOfOutputs = np.zeros(Opt['Gen']['NoOfGPs'])
    stdOfOutputs = np.zeros(Opt['Gen']['NoOfGPs'])

    for i in range(0, Y.shape[1]):
        MeanOfOutputs[i] = np.mean(Y[:, i])
        stdOfOutputs[i] = np.std(Y[:, i])
        if stdOfOutputs[i] == 0.0:
            constCol = i+1
            break

        Ynew[:, i] = (Y[:, i] - MeanOfOutputs[i]) / stdOfOutputs[i]

    return {
        'Xnew': Xnew,
        'Ynew': Ynew,
        'constCol': constCol
    }

def sqdist(X1, X2):
      AA = np.sum(X1 * X1, axis=0)
      BB = np.sum(X2 * X2, axis=0)
      AB = X1.T @ X2

      D1 = np.tile(AA, (BB.size, 1)).T
      D2 = np.tile(BB, (AA.size, 1))

      D = D1 + D2 - 2 * AB
      D[D < 0] = 0

      return D

def priorGauss(mu,s2,x):
    lp = -(x-mu)**2/(2*s2) - np.log(2*np.pi*s2)/2
    dlp = -(x-mu)/s2

    return [lp, dlp]

def covMaternanisotropic(d, hyp, sqrtK, expnK, dsq_M, x, i):
    n, D = x.shape
    sf2 = np.exp(2 * hyp[D])

    if i < D:
        Ki = dsq_M[:, (i * n):((i+1) * n)]
        if d == 3:
            dm = expnK
        elif d == 1:
            t = sqrtK
            with np.errstate(divide='ignore', invalid='ignore'):
                dm = (1 / t) * expnK
        elif d == 5:
            t = sqrtK
            dm = ((1+t) / 3) * expnK
        elif np.isinf(d):
            dm = -1 / 2 * expnK
        with np.errstate(divide='ignore', invalid='ignore'):
            K = sf2 * dm * Ki
        K[Ki < 1e-12] = 0  # fix limit case for d=1
    elif i == D:  # magnitude parameter
        if d == 3:
            t = sqrtK
            m = (1 + t) * expnK
        elif d == 1:
            m = expnK
        elif d == 5:
            t = sqrtK
            m = (1 + t * (1+t / 3)) * expnK
        elif np.isinf(d):
            m = expnK
        K = 2 * sf2 * m

    return K


def cholesky(M):
    return scipy.linalg.lapack.dpotrf(M, False, False)[0]


def inverse_from_cholesky(CH):
    invK, info = scipy.linalg.lapack.dpotri(CH)
    return np.triu(invK) + np.triu(invK, k=1).T


def NLikelihood(hypVar, Xnew, Ynew, K_M, Opt_GP):
    n, D = Xnew.shape

    if np.isfinite(Opt_GP['cov']):
        d = Opt_GP['cov']  # type of Martern
    else:
        d = -1

    h1 = Opt_GP['h1']  # number of hyperparameters from covariance
    h2 = Opt_GP['h2']  # number of hyperparameters from likelihood

    hyp_cov = hypVar[0:h1]
    hyp_lik = hypVar[h1:(h1 + h2)]

    ell = np.exp(hyp_cov[0:D])
    sf2 = np.exp(2 * hypVar[D])
    K = np.zeros(shape=(n, n))
    # Calculate covariance matrix
    for i in range(0, D):
        K = K_M[:, (i * n):((i+1) * n)] * d / ell[i]**2 + K

    if np.isfinite(Opt_GP['cov']):
        sqrtK = np.sqrt(K)
        expnK = np.exp(-sqrtK)
    else:
        expnK = np.exp(-1 / 2 * K)
        sqrtK = list()

    if Opt_GP['cov'] == 3:
        t = sqrtK
        m = (1 + t) * expnK
    elif Opt_GP['cov'] == 1:
        m = expnK
    elif Opt_GP['cov'] == 5:
        t = sqrtK
        m = (1 + t * (1+t / 3)) * expnK
    elif np.isinf(Opt_GP['cov']):
        m = expnK

    K = sf2 * m
    idMat = np.identity(n)

    if len(hyp_lik) > 1:
        K = K + idMat @ np.exp(hyp_lik * 2)
    else:
        K = K + idMat * np.exp(hyp_lik * 2)

    K = (K+K.T) / 2  # This guarantees a symmetric matrix

    CH = cholesky(K)
    invK = inverse_from_cholesky(CH)
    logDetK = 2 * sum(np.log(abs(np.diag(CH))))

    logprior = 0

    for i in range(0, h1):
        A, _ = priorGauss(Opt_GP['priorcov'][0], Opt_GP['priorcov'][1], hyp_cov[i])
        logprior = logprior + A

    for i in range(0, h2):
        A, _ = priorGauss(Opt_GP['priorlik'][0], Opt_GP['priorlik'][1], hyp_lik[i])
        logprior = logprior + A

    return n / 2 * np.log(2 * np.pi) + 1 / 2 * logDetK + 1 / 2 * Ynew.T @ invK @ Ynew - logprior


def NLikelihoodGrad(hypVar, Xnew, Ynew, K_M, Opt_GP):
    n, D = Xnew.shape

    if np.isfinite(Opt_GP['cov']):
        d = Opt_GP['cov']  # type of Martern
    else:
        d = -1

    h1 = Opt_GP['h1']  # number of hyperparameters from covariance
    h2 = Opt_GP['h2']  # number of hyperparameters from likelihood

    hyp_cov = hypVar[0:h1]
    hyp_lik = hypVar[h1:(h1 + h2)]

    ell = np.exp(hyp_cov[0:D])
    sf2 = np.exp(2 * hypVar[D])
    K = np.zeros(shape=(n, n))

    for i in range(0, D):
        K = K_M[:, (i * n):((i+1) * n)] * d / ell[i]**2 + K

    if np.isfinite(Opt_GP['cov']):
        sqrtK = np.sqrt(K)
        expnK = np.exp(-sqrtK)
    else:
        expnK = np.exp(-1 / 2 * K)
        sqrtK = list()

    if Opt_GP['cov'] == 3:
        t = sqrtK
        m = (1 + t) * expnK
    elif Opt_GP['cov'] == 1:
        m = expnK
    elif Opt_GP['cov'] == 5:
        t = sqrtK
        m = (1 + t * (1+t / 3)) * expnK
    elif np.isinf(Opt_GP['cov']):
        m = expnK

    K = sf2 * m
    idMat = np.identity(n)

    if len(hyp_lik) > 1:
        K = K + idMat @ np.exp(hyp_lik * 2)
    else:
        K = K + idMat * np.exp(hyp_lik * 2)[0]

    K = (K+K.T) / 2  # This guarantees a symmetric matrix

    CH = cholesky(K)
    invK = inverse_from_cholesky(CH)

    dlogpriorcov = np.zeros(h1)

    for i in range(0, h1):
        A, dlogpriorcov[i] = priorGauss(Opt_GP['priorcov'][0], Opt_GP['priorcov'][1], hyp_cov[i])

    dlogpriorlik = np.zeros(h2)

    for i in range(0, h2):
        A, dlogpriorlik[i] = priorGauss(Opt_GP['priorlik'][0], Opt_GP['priorlik'][1], hyp_lik[i])

    dNLL_f_cov = np.zeros(h1)
    dNLL_f_lik = np.zeros(h2)

    dsq_M = np.zeros(shape=(n, n * D))

    for i in range(0, D):
        dsq_M[:, (i * n):((i + 1) * n)] = K_M[:, (i * n):((i + 1) * n)] * d / ell[i]**2

    c = invK @ Ynew

    for i in range(0, h1):
        dK = covMaternanisotropic(Opt_GP['cov'], hyp_cov, sqrtK, expnK, dsq_M, Xnew, i)
        b = invK @ dK
        dNLL_f_cov[i] = (1 / 2 * sum(np.diag(b)) - 1 / 2 * Ynew.T @ b @ c).item()

    for i in range(0, h2):
        dK = 2 * np.exp(hyp_lik[i]) * idMat * np.exp(hyp_lik[i])
        b = invK @ dK
        dNLL_f_lik[i] = (1 / 2 * sum(np.diag(b)) - 1 / 2 * Ynew.T @ b @ c).item()

    return np.append(dNLL_f_cov, dNLL_f_lik) - np.append(dlogpriorcov, dlogpriorlik)


def obj_fun(hypVar, Xnew, Ynew, K_M, OptGP):
    return NLikelihood(hypVar, Xnew, Ynew, K_M, OptGP)


def obj_fun_grad(hypVar, Xnew, Ynew, K_M, OptGP):
    return NLikelihoodGrad(hypVar, Xnew, Ynew, K_M, OptGP)

def TrainingOfGP(Xnew, Ynew, Opt_GP):
    # Function which minimizes the neg-loglikelihood to find hyperparameters

    # Initialize variables
    n, D = Xnew.shape

    # Set initial hyperparameters
    h1 = Opt_GP['h1']  # number of hyperparameters from covariance
    h2 = Opt_GP['h2']  # number of hyperparameters from likelihood

    # Calculation of squared-distance matrix
    a = Xnew.T
    K_M = np.zeros(shape=(n, n*D))
    for i in range(0, D):
        x = a[i,:]
        x = np.reshape(x, (1, x.size))
        K_M[:, (i * n):((i+1) * n)] = sqdist(x, x)

    # Minimize log-negative likeliehood

    # Define bounds
    lb = np.ones(h1+h2) * np.log(np.sqrt(10 ** (-3)))  # see Jones paper
    ub = np.ones(h1+h2) * np.log(np.sqrt(10 ** (3)))  # see Jones paper
    lb[h1+h2-1] = -6
    ub[h1+h2-1] = Opt_GP['noiselimit']
    bounds = np.array([lb, ub]).T

    # Defintion of options for global search
    useropts = {
        'maxevals': Opt_GP['fun_eval'] * (h1+h2),
        'maxits': 100000 * (h1+h2),
        'maxdeep': 100000 * (h1 + h2),
        'showits': 0
    }

    [y, x0] = Direct(obj_fun, bounds, useropts, Xnew=Xnew, Ynew=Ynew, K_M=K_M, OptGP=Opt_GP)

    result = scipy.optimize.minimize(obj_fun, x0, method='L-BFGS-B', jac=obj_fun_grad, bounds=bounds, tol=1e-12, args=(Xnew, Ynew, K_M, Opt_GP))
    return {
        'cov': result['x'][0:h1],
        'lik': result['x'][h1:(h1 + h2)]
    }


def posterior_sample(Xnew, Ynew, Opt):
    # extration of variables from problem structure
    nSpectralpoints = Opt['nSpectralpoints']
    n, D = np.shape(Xnew)

    ell = np.exp(Opt['hyp']['cov'][0:D])
    sf2 = np.exp(2 * Opt['hyp']['cov'][D])
    sn2 = np.exp(2 * Opt['hyp']['lik'])

    # Sampling of W and b
    sampler = qmc.LatinHypercube(d=D)
    sW1 = sampler.random(n=nSpectralpoints)
    sW2 = sampler.random(n=nSpectralpoints)
    if np.isfinite(Opt['cov']):
        W = np.tile(1 / ell, (nSpectralpoints, 1)) * norm.ppf(sW1) * np.sqrt(Opt['cov'] / chi2.ppf(sW2, Opt['cov']))
    else:
        W = norm.rvs(size=nSpectralpoints, loc=D) * np.tile(1 / ell, (nSpectralpoints, 1))

    sampler = qmc.LatinHypercube(d=1)
    b = 2 * np.pi * sampler.random(n=nSpectralpoints)

    # Calculation of phi
    phi = np.sqrt(2 * sf2 / nSpectralpoints) * np.cos(W @ Xnew.T + np.tile(b, n))

    # Sampling of theta according to phi
    idMat = np.identity(nSpectralpoints)

    A = phi @ phi.T + sn2 * idMat
    CH = cholesky(A)
    invA = inverse_from_cholesky(CH)

    mu_theta = invA @ phi @ Ynew
    cov_theta = sn2 * invA
    cov_theta = (cov_theta + cov_theta.T) / 2

    rng = np.random.default_rng()
    theta = rng.multivariate_normal(mean=mu_theta, cov=cov_theta, size=1, method='cholesky')[0]

    return {
        'theta': theta,
        'sf2': sf2,
        'nSpectralpoints': nSpectralpoints,
        'W': W,
        'b': b
    }


class ParetoObjective(pymoo.core.problem.Problem):

    def __init__(self, inputDim, objDim, ModelParams):
        self.modelParams = ModelParams
        super().__init__(n_var=inputDim, n_obj=objDim, n_constr=0, xl=np.zeros(inputDim), xu=np.ones(inputDim))

    def _evaluate(self, x, out, *args, **kwargs):
        fvals = list()
        for i in range(0, len(self.modelParams)):
            theta = self.modelParams[i]['theta']
            sf2 = self.modelParams[i]['sf2']
            nSpectralpoints = self.modelParams[i]['nSpectralpoints']
            W = self.modelParams[i]['W']
            b = self.modelParams[i]['b']
            f = (theta * np.sqrt(2 * sf2 / nSpectralpoints)) @ np.cos(W @ x.T + np.tile(b, np.shape(x)[0]))
            fvals.append(f)

        out["F"] = np.column_stack(fvals)


def Find_sample_pareto(Opt):
    algorithm = NSGA2(
        pop_size=Opt['pop']
    )

    stop_criteria = ('n_gen', Opt['Generation'])
    problem = ParetoObjective(Opt['Gen']['NoOfInputDim'], Opt['Gen']['NoOfGPs'], Opt['Sample'])
    res = pymoo.optimize.minimize(problem=problem, algorithm=algorithm, termination=stop_criteria, verbose=False)

    return {
        'Sample_pareto': res.F,
        'Sample_xpareto': res.X,
        'Sample_nadir': np.max(res.F, axis=0)
    }


def paretofront(B):
    sz1 = np.shape(B)[0]
    jj = 0
    kk = np.zeros(sz1, dtype=int)
    cmat = np.zeros(shape=(sz1, np.shape(B)[1]))
    bb = cmat
    for k in range(0, sz1):
        j = 0
        ak = B[k, :]
        for i in range(0, sz1):
            if i != k:
                bb[j, :] = ak-B[i, :]
                j += 1

        if np.all([np.any(row) for row in (bb[0:j, :] < 0)]):
            cmat[jj, :] = ak
            kk[jj] = k
            jj += 1

    b = np.full(sz1, False)
    b[kk[0:jj]] = True

    return b

# Sorting data frames along 1st column, ties along 2nd, ... *arbitrary* no.{columns}
def sortrows(A):
    return A[np.lexsort(np.flip(A, 1).T)]

def remove_points_above_reference(Afront, r):
    A = sortrows(Afront)
    for p in range(0, np.shape(Afront)[1]):
        A = A[A[:, p] <= r[p], :]

    return A

def hypervolume2D(F, ub):
    F1 = F.T
    F  = -F1 + np.ones(shape=np.shape(F1))
    F1 = F.T
    L1 = F1[F1[:, 0].argsort(), :]
    L  = L1.T
    l  = np.shape(L)[1]
    ub = ub + np.ones(np.shape(L)[0])
    hypervolume = 0
    for i in range(0,l):
        hypervolume = hypervolume + ((L[0,i] - ub[0]) * (L[1,i] - ub[1]))
        ub[1] = L[1,i]

    return hypervolume

def hypervolume_2D(Yfront, r):
    AYfront = remove_points_above_reference(Yfront, r)

    if np.shape(AYfront)[0] == 0:
        hv = 0
    else:
        normvec = np.min(AYfront, axis=0)
        A = AYfront - np.tile(normvec, (np.shape(AYfront)[0], 1))
        B = np.identity(len(normvec))
        np.fill_diagonal(B, 1/(r-normvec))
        A = A @ B
        A = -A + np.ones(shape=np.shape(A))
        A = A[A[:, 1].argsort(), :]
        hyp_percentage = hypervolume2D(A, np.array([0,0]))
        hv = np.prod(r-normvec) * hyp_percentage

    return hv

def weakly_dominates(fA, fB):
    d = True
    for i in range(0, len(fA)):
        if fA[i] > fB[i]:
            d = False
            break

    return d


def nd_filter(L, spawn_vector, ub):
    l_L = np.shape(L)[1]
    M = np.shape(spawn_vector)[0]
    l_sp = np.shape(spawn_vector)[0]
    do_assign = np.zeros(l_sp)

    for i in range(0, l_sp):
        at_ub = False
        for j in range (0,M):
            if spawn_vector[j, i] == ub[j]:
                at_ub = True
                break

        if not at_ub:
            do_assign[i] = 1
            for j in range(0, l_L):
                if weakly_dominates(L[:, j], spawn_vector[:, i]):
                    do_assign[i] = 0
                    break

    L = np.concatenate((spawn_vector[:, do_assign == 1], L), axis=1)

    return L


def hypervolume3D(F, ub, lb):
    hypervolume = 0
    F1 = F.T
    F = -F1 + np.ones(shape=np.shape(F1))
    M, l = np.shape(F)

    ub = ub + np.ones(M)

    L1 = np.unique(F.T, axis=0)
    L1 = L1[L1[:, 0].argsort(), :]
    L = L1.T

    while l >= 1:
        if l > 1:
            b = np.zeros(M)
            spawn_vector = np.tile(L[:, 0], (M, 1)).T
            for i in range(0,M):
                difL = L[i, 1:L.shape[1]] - L[i, 0]
                lub = np.flatnonzero(difL > 0)
                if len(lub) > 0:
                    b[i] = np.min(L[i, lub+1])
                else:
                    b[i] = ub[i]

                b[i] = np.min((difL > 0) * L[i, 1:L.shape[1]] + (difL <= 0) * ub[i])
                spawn_vector[i, i] = b[i]

            # Compute lop-Off volume and update lebesgue measure
            lov = np.prod(b - L[:, 0])
            hypervolume = hypervolume + lov

            L = np.delete(L, 0, axis=1)
            L = nd_filter(L, spawn_vector, ub)
            M, l = np.shape(L)
        else:
            lov = np.prod(ub - L[:, 0])
            hypervolume = hypervolume + lov
            L = []
            M = 0
            l = 0

    return hypervolume

def hypervolume_3D(Yfront, r):
    AYfront = remove_points_above_reference(Yfront, r)
    if np.shape(AYfront)[0] == 0:
        hv = 0
    else:
        normvec = np.min(AYfront, axis=0)
        A = AYfront - np.tile(normvec, (np.shape(AYfront)[0], 1))
        B = np.identity(len(normvec))
        np.fill_diagonal(B, 1 / (r - normvec))
        A = A @ B
        A = -A + np.ones(shape=np.shape(A))
        A = A[A[:, 2].argsort(), :]
        hyp_percentage = hypervolume3D(A, np.array([0, 0, 0]), np.array([1, 1, 1]))
        hv = np.prod(r - normvec) * hyp_percentage

    return hv


def hypervolumemonte(P, r, N):
    n, d = np.shape(P)

    B = np.identity(d)
    np.fill_diagonal(B, 1 / r)

    P = P @ B

    C = np.random.random((N, d))

    fDominated = np.full(N, False)
    lB = np.min(P, axis=0)

    fcheck = np.array([np.all(row > lB) for row in C])

    for k in range(0,n):
        if np.any(fcheck):
            f = np.array([np.all(row > P[k, :]) for row in C[fcheck, :]])
            fDominated[fcheck] = f
            fcheck[fcheck] = ~f

    return np.sum(fDominated) / N


def hypervolume_improvement_index(Ynew, Sample_nadir, Sample_pareto, Opt):

    Sample_pareto_rows = np.shape(Sample_pareto)[0]
    hv_improvement = np.zeros(Sample_pareto_rows)

    r = Sample_nadir + 0.01 * (np.max(Sample_pareto, axis=0) - np.min(Sample_pareto, axis=0))
    index = []

    for i in range(0, Opt['NoOfBachSequential']):
        Yfront = Ynew[paretofront(Ynew), :]
        Ynew_cols = np.shape(Ynew)[1]
        if (Ynew_cols == 2):
            hvY = hypervolume_2D(Yfront, r)
            for k in range(0, Sample_pareto_rows):
                #A = np.concatenate((Ynew, Sample_pareto[k:(k+1), :]), axis=0)
                A = np.row_stack((Ynew, Sample_pareto[k, :]))
                Afront = A[paretofront(A), :]
                hv = hypervolume_2D(Afront, r)
                hv_improvement[k] = hv - hvY
        elif (Ynew_cols == 3):
            hvY = hypervolume_3D(Yfront, r)
            for k in range(0, Sample_pareto_rows):
                #A = np.concatenate((Ynew, Sample_pareto[k:(k+1), :]), axis=0)
                A = np.row_stack((Ynew, Sample_pareto[k, :]))
                Afront = A[paretofront(A), :]
                hv = hypervolume_3D(Afront, r)
                hv_improvement[k] = hv - hvY
        else:
            AYfront = remove_points_above_reference(Yfront, r)
            normvec = np.min(AYfront, axis=0)
            hyp_percentage = hypervolumemonte(AYfront - np.tile(normvec, (np.shape(AYfront)[0], 1)), r - normvec, 3000)
            hvY = np.prod(r - normvec) * hyp_percentage
            for k in range(0, Sample_pareto_rows):
                #B = np.concatenate((Ynew, Sample_pareto[k:(k+1), :]), axis=0)
                B = np.row_stack((Ynew, Sample_pareto[k, :]))
                Bfront = B[paretofront(B), :]
                ABfront = remove_points_above_reference(Bfront, r)
                if (np.shape(ABfront)[0] == 0):
                    hv_improvement[k] = 0
                else:
                    normvec = np.min(ABfront, axis=0)
                    hyp_percentage = hypervolumemonte(ABfront - np.tile(normvec, (np.shape(ABfront)[0], 1)), r-normvec, 10000)
                    hv = np.prod(r-normvec) * hyp_percentage
                    hv_improvement[k] = hv-hvY

        if i == 0:
            hvY0 = hvY

        Currentindex = np.argmax(hv_improvement)
        Ynew = np.concatenate((Ynew, Sample_pareto[Currentindex:(Currentindex+1), ]), axis=0)
        index.append(Currentindex)

    hv_imp = hv_improvement[index[-1]] + hvY - hvY0

    return {
        'index': index,
        'hv_imp': hv_imp
    }


def mean_sample(Xnew, Ynew, Opt):
    nSpectralpoints = Opt['nSpectralpoints']
    n, D = np.shape(Xnew)

    ell = np.exp(Opt['hyp']['cov'][0:D])
    sf2 = np.exp(2 * Opt['hyp']['cov'][D])
    sn2 = np.exp(2 * Opt['hyp']['lik'])

    # Sampling of W and b
    sampler = qmc.LatinHypercube(d=D)
    sW1 = sampler.random(n=nSpectralpoints)
    sW2 = sampler.random(n=nSpectralpoints)
    if np.isfinite(Opt['cov']):
        W = np.tile(1 / ell, (nSpectralpoints, 1)) * norm.ppf(sW1) * np.sqrt(Opt['cov'] / chi2.ppf(sW2, Opt['cov']))
    else:
        W = norm.rvs(size=nSpectralpoints, loc=D) * np.tile(1 / ell, (nSpectralpoints, 1))

    sampler = qmc.LatinHypercube(d=1)
    b = 2 * np.pi * sampler.random(n=nSpectralpoints)

    # Calculation of phi
    phi = np.sqrt(2 * sf2 / nSpectralpoints) * np.cos(W @ Xnew.T + np.tile(b, n))

    # Sampling of theta according to phi
    idMat = np.identity(nSpectralpoints)

    A = phi @ phi.T + sn2 * idMat
    CH = cholesky(A)
    invA = inverse_from_cholesky(CH)

    mu_theta = invA @ phi @ Ynew

    return {
        'theta': mu_theta.T,
        'sf2': sf2,
        'nSpectralpoints': nSpectralpoints,
        'W': W,
        'b': b,
        'sn2': sn2,
        'invA': invA
    }

def Find_mean_pareto(Opt):
    algorithm = NSGA2(
        pop_size=Opt['pop']
    )

    stop_criteria = ('n_gen', Opt['Generation'])
    problem = ParetoObjective(Opt['Gen']['NoOfInputDim'], Opt['Gen']['NoOfGPs'], Opt['Mean'])
    res = pymoo.optimize.minimize(problem=problem, algorithm=algorithm, termination=stop_criteria, verbose=False)

    return {
        'Mean_pareto': res.F,
        'Mean_xpareto': res.X
    }

def varf_fun(x, fParam):
    phi_x = np.sqrt(2 * fParam['sf2'] / fParam['nSpectralpoints']) * np.cos(fParam['W'] @ np.array([x]).T + np.tile(fParam['b'], 1))
    return fParam['sn2'] + fParam['sn2'] @ phi_x.T @ fParam['invA'] @ phi_x



def create_log_file(X, Y, lb, ub, Opt, log_file_name):
    try:
        log_file = open(log_file_name, "w", encoding="utf-8")

        now = datetime.now()
        log_file.write("TSEMO log file created on " + now.strftime("%d.%m.%Y, %H:%M:%S") + "\n")

        line_str = "¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\n"
        log_file.write(line_str)

        log_file.write("Problem specifications\n\n")
        log_file.write(f"Number of inputs: {np.shape(X)[1]}\n")
        log_file.write(f"Number of outputs: {np.shape(Y)[1]}\n\n")

        log_file.write("Lower bounds of decision variables:\n\n")
        text = " ".join('%8.4f'%F for F in lb)
        log_file.write(text + "\n\n")

        log_file.write("Upper bounds of decision variables:\n\n")
        text = " ".join('%8.4f' %F for F in ub)
        log_file.write(text + "\n\n")

        log_file.write(line_str)
        log_file.write("Algorithm options\n\n")

        log_file.write(f"Maximum number of function evaluations: {Opt['maxeval']}\n")
        log_file.write(f"Sample batch size: {Opt['NoOfBachSequential']}\n")
        log_file.write(f"Number of algorithm iterations: {math.ceil(Opt['maxeval']/Opt['NoOfBachSequential'])}\n\n")

        log_file.write(f"Genetic algorithm population size: {Opt['pop']}\n")
        log_file.write(f"Genetic algorithm number of generations: {Opt['Generation']}\n\n")

        text = ", ".join(str(opt['nSpectralpoints']) for opt in Opt['GP'])
        log_file.write(f"Number of spectral sampling points: {text}\n")

        text = ", ".join(str(opt['matern']) for opt in Opt['GP'])
        log_file.write(f"Type of matern function: {text}\n")

        text = ", ".join(str(opt['fun_eval']) for opt in Opt['GP'])
        log_file.write(f"Direct evaluations per input dimension: {text}\n")
        log_file.write(line_str)

        log_file.write("Initial data set\n\n")

        log_file.write(f"Number of initial data points: {np.shape(X)[0]}\n\n")

        log_file.write("Initial input data matrix:\n\n")

        for x in X:
            text = " ".join('%8.4f' % F for F in x)
            log_file.write(text + "\n")

        log_file.write("\n\n")
        log_file.write("Initial output data matrix:\n\n")

        for y in Y:
            text = " ".join('%8.4f' % F for F in y)
            log_file.write(text + "\n")

        log_file.write(line_str)
        log_file.close()
    except Exception as e:
        pass

def update_log_file(it,hv_imp,xnewtrue,ytrue,log_file_name):
    try:
        log_file = open(log_file_name, "a", encoding="utf-8")

        line_str = "¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\n"

        log_file.write("\n\n")

        log_file.write(f"Algorithm iteration {it+1}\n\n")
        log_file.write(f"Predicted hypervolume improvement: {hv_imp:.4f}\n")

        log_file.write("Proposed evaluation point(s):\n\n")

        for x in xnewtrue:
            text = " ".join('%8.4f' % F for F in x)
            log_file.write(text + "\n")

        log_file.write("\n\n")

        log_file.write("Corresponding observation(s):\n\n")

        for y in ytrue:
            text = " ".join('%8.4f' % F for F in y)
            log_file.write(text + "\n")

        log_file.write(line_str)
        log_file.close()

    except:
        pass

def final_log_update(Xpareto,Ypareto,XParetoGP,YParetoGP,log_file_name):
    try:
        log_file = open(log_file_name, "a", encoding="utf-8")

        log_file.write("\n\n")

        log_file.write(f"Final algorithm output\n\n")

        log_file.write(f"Input data matrix of corresponding Pareto front:\n\n")

        for x in Xpareto:
            text = " ".join('%8.4f' % F for F in x)
            log_file.write(text + "\n")

        log_file.write("\n\n")

        log_file.write(f"Output data matrix of corresponding Pareto front:\n\n")

        for y in Ypareto:
            text = " ".join('%8.4f' % F for F in y)
            log_file.write(text + "\n")

        log_file.write("\n\n")

        log_file.write(f"Input data matrix of Pareto front of final Gaussian process model:\n\n")

        for x in XParetoGP:
            text = " ".join('%8.4f' % F for F in x)
            log_file.write(text + "\n")

        log_file.write("\n\n")

        log_file.write(f"Output data matrix of Pareto front of final Gaussian process model:\n\n")

        for y in YParetoGP:
            text = " ".join('%8.4f' % F for F in y)
            log_file.write(text + "\n")


        log_file.close()
    except:
        pass

def error_log_file(errorDesc,log_file_name):
    try:
        log_file = open(log_file_name, "a")

        log_file.write("\n\n")
        log_file.write(f"Optimization error: {errorDesc}\n\n")
        log_file.close()

    except:
        pass




def TSEMO_calc_pareto(Y, Xnew, Ynew, lb, ub, Opt):
    hypf = np.zeros(shape=(Opt['Gen']['NoOfInputDim'] + 2, Opt['Gen']['NoOfGPs']))
    for j in range(0, Opt['Gen']['NoOfGPs']):
        covhyp = np.exp(Opt['GP'][j]['hyp']['cov'])
        hypf[:, j] = np.concatenate((covhyp[0:Opt['Gen']['NoOfInputDim']] * (ub - lb), [covhyp[-1] * np.std(Y[:, j])],
                                     np.exp(Opt['GP'][j]['hyp']['lik']) * np.std(Y[:, j])))

    Opt['Mean'] = list()
    for j in range(0, Opt['Gen']['NoOfGPs']):
        Opt['Mean'].append(mean_sample(Xnew, Ynew[:, j], Opt['GP'][j]))

    res = Find_mean_pareto(Opt)
    Mean_pareto = res['Mean_pareto']
    Mean_xpareto = res['Mean_xpareto']

    XParetoGP = np.zeros(shape=(np.shape(Mean_xpareto)[0], Opt['Gen']['NoOfInputDim']))
    for j in range(0, Opt['Gen']['NoOfInputDim']):
        XParetoGP[:, j] = Mean_xpareto[:, j] * (ub[j] - lb[j]) + lb[j]

    YParetoGP = np.zeros(shape=(np.shape(Mean_pareto)[0], Opt['Gen']['NoOfGPs']))
    for j in range(0, Opt['Gen']['NoOfGPs']):
        YParetoGP[:, j] = Mean_pareto[:, j] * np.std(Y[:, j]) + np.mean(Y[:, j])

    YParetoGPstd = np.zeros(shape=(Opt['pop'], Opt['Gen']['NoOfGPs']))
    for j in range(0, Opt['Gen']['NoOfGPs']):
        for k in range(0, Opt['pop']):
            x = Mean_xpareto[k, :]
            varf = varf_fun(x, Opt['Mean'][j])
            std_dev = np.std(Y[:, j])
            YParetoGPstd[k, j] = np.sqrt(varf[0] * std_dev)

    return hypf, XParetoGP, YParetoGP, YParetoGPstd



def TSEMO(fPoint, fInfo, X, Y, lb, ub, Opt, log_file_name, backup_steps, backup_folder, backup_name, backup_header):
    # ALGORITHM  Executes the optimization algorithm.

    #   OUTPUTS
    #       Xpareto      Pareto front approximation from X inputs       [np,D]
    #       Ypareto      Pareto front approximation from Y outputs      [np,O]
    #       X            Data input vector                              [n+meval,D]
    #       Y            Data output vector                             [n+meval,O]
    #       XParetoGP    Pareto front approximation of GP model inputs  [npGP,D]
    #       YParetoGP    Pareto front approximation of GP model outputs [npGP,D]
    #       YParetoGPstd Pareto front standard deviation of GP model    [npGP,D]
    #       hypf         Final hyperparameter values []                 [D+2,O]

    #   INPUTS
    #       f       objective function
    #       X       input values of given data set  [n,D]
    #       Y       output values of given data set [n,O]
    #       lb      lower bounds of input variables [1,D]
    #       ub      upper bounds of input variables [1,D]
    #       Opt     options struct of algorithm

    #   with
    #       n       number of given data points
    #       meval   maximum number of function evaluations
    #       np      number of pareto points of the final dataset
    #       npGP    number of pareto points of GP model dataset
    #       D       dimension of input space
    #       O       dimension of output space

    # Initialize option structure
    it = 0
    Opt = set_option_structure(Opt, X, Y)

    create_log_file(X,Y,lb,ub,Opt,log_file_name)

    XParetoGP = None
    YParetoGP = None
    YParetoGPstd = None

    tot_iterations = np.ceil(Opt['maxeval'] / Opt['NoOfBachSequential']).astype('int')

    for i in range(0, tot_iterations):
        fInfo(f"Zacetek nove iteracije ({i + 1} od {tot_iterations})")
        res = ScaleVariables(X, Y, lb, ub, Opt)
        Xnew = res['Xnew']
        Ynew = res['Ynew']
        if res['constCol'] is not None:
            error_log_file(f"Constant column {res['constCol']} in the output data matrix!", log_file_name)
            return {
                'Succeed': False,
                'Desc': f"Konstanten stolpec {res['constCol']}",
                'val': res['constCol']
            }


        for j in range(0, Opt['Gen']['NoOfGPs']):
            Opt['GP'][j]['hyp'] = TrainingOfGP(Xnew, Ynew[:, j], Opt['GP'][j])

        Opt['Sample'] = list()
        for j in range(0, Opt['Gen']['NoOfGPs']):
            Opt['Sample'].append(posterior_sample(Xnew, Ynew[:, j], Opt['GP'][j]))

        res = Find_sample_pareto(Opt)
        Sample_pareto = res['Sample_pareto']
        Sample_xpareto = res['Sample_xpareto']
        Sample_nadir = res['Sample_nadir']

        Opt['warmstart_pareto'] = Sample_xpareto

        res = hypervolume_improvement_index(Ynew, Sample_nadir, Sample_pareto, Opt)
        index = res['index']
        hv_imp = res['hv_imp']

        xNew = Sample_xpareto[index, :]
        Xnew = np.row_stack((Xnew, xNew))

        xnewtrue = np.zeros(shape=(np.shape(xNew)[0], Opt['Gen']['NoOfInputDim']))
        for j in range(0, Opt['Gen']['NoOfInputDim']):
            xnewtrue[:, j] = xNew[:, j] * (ub[j] - lb[j]) + lb[j]

        ytrue = np.zeros(shape=(np.shape(xnewtrue)[0], np.shape(Y)[1]))
        for l in range(0, np.shape(xnewtrue)[0]):
            fInfo(f"Meritev nove tocke")
            ytrue[l, :] = fPoint(xnewtrue[l, :])

        X = np.row_stack((X, xnewtrue))
        Y = np.row_stack((Y, ytrue))

        Ynew = np.zeros(shape=(np.shape(Y)[0], Opt['Gen']['NoOfGPs']))
        for j in range(0, Opt['Gen']['NoOfGPs']):
            Ynew[:, j] = (Y[:, j] - np.mean(Y[:, j])) / np.std(Y[:, j])

        front = paretofront(Y)
        Xpareto = X[front, :]
        Ypareto = Y[front, :]

        update_log_file(it,hv_imp,xnewtrue,ytrue,log_file_name)

        if (it == 0):
            print('%10s %10s %10s \n' % ('Iteration', 'HypImp', 'Time(s)'))

        toc = 0
        print('%10d %10.4g %10.3g \n' % (it, hv_imp, toc))

        it += 1

        # ali je ze cas, da zapisemo backup?
        if backup_steps > 0 and it < tot_iterations and it % backup_steps == 0:
            hypf, XParetoGP, YParetoGP, YParetoGPstd = TSEMO_calc_pareto(Y, Xnew, Ynew, lb, ub, Opt)
            if not os.path.exists(backup_folder):
                os.makedirs(backup_folder)

            backup_csv_file = open(backup_folder + "pareto_" + backup_name + "_step_" + str(it) + ".csv", "w")
            backup_csv_file.write(backup_header)

            for row in range(0, len(Xpareto)):
                line = ",".join(map(str, Xpareto[row])) + "," + ",".join(map(str, Ypareto[row])) + "\n"
                backup_csv_file.write(line)

            backup_csv_file.close()

            backup_csv_file = open(backup_folder + "paretoGP_" + backup_name + "_step_" + str(it) + ".csv", "w")
            backup_csv_file.write(backup_header)

            for row in range(0, len(XParetoGP)):
                line = ",".join(map(str, XParetoGP[row])) + "," + ",".join(map(str, YParetoGP[row])) + "\n"
                backup_csv_file.write(line)

            backup_csv_file.close()




    for j in range(0, Opt['Gen']['NoOfGPs']):
        Opt['GP'][j]['hyp'] = TrainingOfGP(Xnew, Ynew[:, j], Opt['GP'][j])

    # hypf = np.zeros(shape=(Opt['Gen']['NoOfInputDim'] + 2, Opt['Gen']['NoOfGPs']))
    # for j in range(0, Opt['Gen']['NoOfGPs']):
    #     covhyp = np.exp(Opt['GP'][j]['hyp']['cov'])
    #     hypf[:, j] = np.concatenate((covhyp[0:Opt['Gen']['NoOfInputDim']] * (ub - lb), [covhyp[-1] * np.std(Y[:, j])], np.exp(Opt['GP'][j]['hyp']['lik']) * np.std(Y[:, j])))
    #
    # Opt['Mean'] = list()
    # for j in range(0, Opt['Gen']['NoOfGPs']):
    #     Opt['Mean'].append(mean_sample(Xnew, Ynew[:, j], Opt['GP'][j]))
    #
    # res = Find_mean_pareto(Opt)
    # Mean_pareto = res['Mean_pareto']
    # Mean_xpareto = res['Mean_xpareto']
    #
    # XParetoGP = np.zeros(shape=(np.shape(Mean_xpareto)[0], Opt['Gen']['NoOfInputDim']))
    # for j in range(0, Opt['Gen']['NoOfInputDim']):
    #     XParetoGP[:, j] = Mean_xpareto[:, j] * (ub[j] - lb[j]) + lb[j]
    #
    # YParetoGP = np.zeros(shape=(np.shape(Mean_pareto)[0], Opt['Gen']['NoOfGPs']))
    # for j in range(0, Opt['Gen']['NoOfGPs']):
    #     YParetoGP[:, j] = Mean_pareto[:, j] * np.std(Y[:, j]) + np.mean(Y[:, j])
    #
    # YParetoGPstd = np.zeros(shape=(Opt['pop'], Opt['Gen']['NoOfGPs']))
    # for j in range(0, Opt['Gen']['NoOfGPs']):
    #     for k in range(0, Opt['pop']):
    #         x = Mean_xpareto[k, :]
    #         varf = varf_fun(x, Opt['Mean'][j])
    #         std_dev = np.std(Y[:, j])
    #         YParetoGPstd[k, j] = np.sqrt(varf[0] * std_dev)

    hypf, XParetoGP, YParetoGP, YParetoGPstd = TSEMO_calc_pareto(Y, Xnew, Ynew, lb, ub, Opt)

    final_log_update(Xpareto,Ypareto,XParetoGP,YParetoGP,log_file_name)

    return {
        'Succeed': True,
        'Xpareto': Xpareto,
        'Ypareto': Ypareto,
        'X': X,
        'Y': Y,
        'XParetoGP': XParetoGP,
        'YParetoGP': YParetoGP,
        'YParetoGPstd': YParetoGPstd,
        'hypf': hypf
    }


##############################################################################################################
#
# TSEMO_example
#
##############################################################################################################

## Specify problem

def test_fun(x, size):
    dim = 2

    transl = 1 / np.sqrt(dim)
    part1 = (x[0] - transl) ** 2 + (x[1] - transl) ** 2
    part2 = (x[0] + transl) ** 2 + (x[1] + transl) ** 2

    f = np.random.randn(size)
    f[0] = 1 - np.exp(-part1)
    f[1] = 1 - np.exp(-part2)
    f[2] = f[0] + f[1]

    return f



##############################################################################################################
#
# FaustoMaster64
#
##############################################################################################################



##############################################################################################################
#
#
# Razred OptimizerThread
#
#
##############################################################################################################

class OptimizerThread(Thread):
    def __init__(self, thread_params):
        super().__init__()

        self.log_file_name = thread_params['log_file_name']
        self.backup_steps = thread_params['backup_steps']
        self.backup_folder = thread_params['backup_folder']
        self.backup_name = thread_params['backup_name']
        self.backup_header = thread_params['backup_header']
        self.num_inputs = thread_params['num_inputs']
        self.num_outputs = thread_params['num_outputs']
        self.lower_bounds = np.array(thread_params['lower_bounds'])
        self.upper_bounds = np.array(thread_params['upper_bounds'])
        self.queue_request = thread_params['optim_queue_req']
        self.queue_response = thread_params['optim_queue_res']
        self.initial_samples_per_var = thread_params['tsemo_initial_samples_per_var']
        self.num_of_iters = thread_params['tsemo_num_of_iters']
        self.num_of_spectral_sample_points = thread_params['tsemo_num_of_spectral_sample_points']
        self.matern_class = thread_params['tsemo_matern_class']
        self.direct_evals = thread_params['tsemo_direct_evals']
        self.ga_pop_size = thread_params['tsemo_ga_pop_size']
        self.ga_num_of_generations = thread_params['tsemo_ga_num_of_generations']
        self.iteration_batch_size = thread_params['tsemo_iteration_batch_size']

    def post_info(self, text):
        data = {
            'value': text,
            'desc': THREAD_MSG_INFO
        }
        self.queue_request.put(data)

    def get_func_val(self, x):
        while True:
            # podaj zahtevo za izvedbo eksperimenta z dolocenimi nastavitvami
            data = {
                'value': x,
                'desc': THREAD_MSG_POINT
            }
            self.queue_request.put(data)
            # vrni rezultat eksperimenta

            data = self.queue_response.get()
            if data['desc'] == THREAD_MSG_RESULT:
                result = data['value']

                if FAKE_TSEMO:
                    return test_fun(x, len(x))
                else:
                    if result is not None:
                        return result
                    else:
                        # TODO TODO TODO Izpisi v log in na zaslon, da je nekaj narobe
                        pass
            else:
                pass

    def run(self):
        no_outputs = self.num_outputs  # number of objectives
        no_inputs = self.num_inputs  # number of decision variables
        lb = self.lower_bounds  # define lower bound on decision variables, [lb1,lb2,...]
        ub = self.upper_bounds  # define upper bound on decision variables, [ub1,ub2,...]
        samples_per_var = self.initial_samples_per_var

        ## Generate initial dataset

        dataset_size = samples_per_var * no_inputs  # initial dataset size
        sampler = qmc.LatinHypercube(d=no_inputs)  # Latin hypercube design
        X = sampler.random(n=dataset_size)

        # sortiramo po zadnjem stolpcu
        X = X[X[:, -1].argsort()]

        Y = np.zeros(shape=(dataset_size, no_outputs))  # corresponding matrix of response data

        for k in range(0, dataset_size):
            X[k, :] = X[k, :] * (ub - lb) + lb  # adjustment of bounds
            self.post_info(f"Izhodiscne meritve ({k+1} od {dataset_size})")
            Y[k, :] = self.get_func_val(X[k, :])  # calculation of response data

        opt = TSEMO_options(no_outputs)			        # call options for solver, see TSEMO_options file to adjust

        opt['maxeval'] = self.num_of_iters
        opt['NoOfBachSequential'] = self.iteration_batch_size
        opt['pop'] = self.ga_pop_size
        opt['Generation'] = self.ga_num_of_generations

        for i in range(0, no_outputs):
            opt['GP'][i]['nSpectralpoints'] = self.num_of_spectral_sample_points
            opt['GP'][i]['matern'] = self.matern_class
            opt['GP'][i]['fun_eval'] = self.direct_evals

        # Total number of iterations = opt$maxeval/opt$NoOfBachSequential
        #
        # Start algorithm to find Pareto front
        result = TSEMO(self.get_func_val, self.post_info, X, Y, lb, ub, opt, self.log_file_name, self.backup_steps, self.backup_folder, self.backup_name, self.backup_header)
        data = {
            'value': result,
            'desc': THREAD_MSG_RESULT
        }
        self.queue_request.put(data)

##############################################################################################################
#
# Razred "ReactorVar"
#
# Predstavlja eno dimenzijo (spremenljivko) eksperimenta.
#
# Dolocena je z zalogo vrednosti, korakom spremembe in trenutno vrednostjo.
#
##############################################################################################################

class ReactorVar:
    name: str
    min_val: float
    max_val: float
    inc_val: float
    cur_val: float

    def __init__(self, name, min_val, max_val, inc_val):
        self.name = name
        self.min_val = min_val
        self.max_val = max_val
        self.inc_val = inc_val
        self.cur_val = min_val

    def reset_val(self):
        self.cur_val = self.min_val

    def increment_val(self):
        self.cur_val += self.inc_val

    def is_over_end(self):
        if self.cur_val > self.max_val:
            return True
        else:
            return False

    def get_val(self):
        return self.cur_val

    def set_val(self, value):
        self.cur_val = round(value, VAR_DIGITS)
        if self.cur_val < self.min_val:
            self.cur_val = self.min_val
        if self.cur_val > self.max_val:
            self.cur_val = self.max_val


##############################################################################################################
#
# Razred "UPLCPeak"
#
# Predstavlja interval vrednosti za retention time ter izmerjeno vrednost za area in conc.
#
##############################################################################################################

class UPLCPeak:
    min_time: float
    max_time: float
    area: float
    conc: float


    def __init__(self, min_time, max_time):
        self.min_time = min_time
        self.max_time = max_time
        self.area = 0.0
        self.conc = 0.0

    def is_inside(self, time_val):
        return

    def set_zero(self):
        self.area = 0.0
        self.conc = 0.0

    def set_val(self, time_val, area_val, conc_val):
        if self.min_time <= time_val and self.max_time >= time_val:
            self.area = area_val
            self.conc = conc_val


##############################################################################################################
#
# Razred "TCPClient"
#
##############################################################################################################

class TCPClient:
    def __init__(self, host, port, outgoint_port, request_text):
        self.sel = selectors.DefaultSelector()
        addr = (host, port)
        logtext = f"Vzpostavljanje povezave z {addr}"
        logger.debug(logtext)
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind(('', outgoint_port))
        sock.setblocking(False)
        sock.connect_ex(addr)
        events = selectors.EVENT_READ | selectors.EVENT_WRITE
        message = MasterMassage(self.sel, sock, addr, request_text)
        self.sel.register(sock, events, data=message)

    def process_socket_events(self):
        response = None
        events = self.sel.select(timeout=0.1)
        for key, mask in events:
            message = key.data
            try:
                message.process_events(mask)
                if message.incoming_text is not None:
                    response = message.incoming_text
                    message.incoming_text = None
            except Exception as e:
                logtext = f"Napaka pri komunikaciji z {message.addr}."
                logger.error(logtext)
                message.close()

        # Check for a socket being monitored to continue.
        if not self.sel.get_map():
            return False, response
        else:
            return True, response

    def shut_down(self):
        self.sel.close()


##############################################################################################################
#
# Razred "MasterMessage"
#
##############################################################################################################

class MasterMassage:
    def __init__(self, selector, sock, addr, outgoing_text):
        self.selector = selector
        self.sock = sock
        self.addr = addr

        self.recv_buffer = b""
        self.send_buffer = b""

        self.outgoing_text = outgoing_text
        self.outgoing_encoded_message_created = False

        self.incoming_encoded_message_len = None
        self.incoming_text = None

    def util_set_selector_events_mask(self, mode):
        """Set selector to listen for events: mode is 'r', 'w', or 'rw'."""
        if mode == "r":
            events = selectors.EVENT_READ
        elif mode == "w":
            events = selectors.EVENT_WRITE
        elif mode == "rw":
            events = selectors.EVENT_READ | selectors.EVENT_WRITE
        else:
            raise ValueError(f"Invalid events mask mode {mode!r}.")
        self.selector.modify(self.sock, events, data=self)

    def util_read_data(self):
        try:
            # Should be ready to read
            data = self.sock.recv(4096)
        except BlockingIOError:
            # Resource temporarily unavailable (errno EWOULDBLOCK)
            pass
        else:
            if data:
                self.recv_buffer += data
            else:
                raise RuntimeError("Peer closed.")

    def util_write_data(self):
        if self.send_buffer:
            logtext = f"Posiljanje {self.send_buffer!r} na {self.addr}."
            logger.debug(logtext)

            try:
                # Should be ready to write
                sent = self.sock.send(self.send_buffer)
            except BlockingIOError:
                # Resource temporarily unavailable (errno EWOULDBLOCK)
                pass
            else:
                self.send_buffer = self.send_buffer[sent:]

    def process_events(self, mask):
        if mask & selectors.EVENT_READ:
            self.read()
        if mask & selectors.EVENT_WRITE:
            self.write()

    def process_incoming_header(self):
        hdrlen = 2
        if len(self.recv_buffer) >= hdrlen:
            self.incoming_encoded_message_len = struct.unpack(">H", self.recv_buffer[:hdrlen])[0]
            self.recv_buffer = self.recv_buffer[hdrlen:]

    def process_incoming_encoded_message(self):
        msglen = self.incoming_encoded_message_len
        if not len(self.recv_buffer) >= msglen:
            return
        data = self.recv_buffer[:msglen]
        self.recv_buffer = self.recv_buffer[msglen:]
        self.incoming_text = data.decode("utf-8")
        logtext = f"Prejem {self.incoming_text!r} od {self.addr}"
        logger.debug(logtext)
        self.close()

    def read(self):
        self.util_read_data()

        if self.incoming_encoded_message_len is None:
            self.process_incoming_header()

        if self.incoming_encoded_message_len is not None:
            if self.incoming_text is None:
                self.process_incoming_encoded_message()

    def write(self):
        if not self.outgoing_encoded_message_created:
            message_hdr = struct.pack(">H", len(self.outgoing_text))
            encoded_message = message_hdr + self.outgoing_text.encode("utf-8")
            self.send_buffer += encoded_message
            self.outgoing_encoded_message_created = True
        else:
            pass
        self.util_write_data()

        if self.outgoing_encoded_message_created:
            if not self.send_buffer:
                # Set selector to listen for read events, we're done writing.
                self.util_set_selector_events_mask("r")

    def close(self):
        logtext = f"Zapiranje komunikacije z {self.addr}."
        logger.debug(logtext)

        try:
            self.selector.unregister(self.sock)
        except Exception as e:
            print(
                f"Error: selector.unregister() exception for "
                f"{self.addr}: {e!r}"
            )

        try:
            self.sock.close()
        except OSError as e:
            print(f"Error: socket.close() exception for {self.addr}: {e!r}")
        finally:
            # Delete reference to socket object for garbage collection
            self.sock = None


##############################################################################################################
#
# Razred "App"
#
##############################################################################################################

class App:

    #
    # Inicializacija vrednosti atributov razreda
    #

    def __init__(self, parent):

        # Glavno okno aplikacije
        self.window = parent
        self.window.title("FaustoMaster")
        self.window.protocol("WM_DELETE_WINDOW", self.close_window)
        self.window.minsize(800, 400)

        # GUI
        self.window.rowconfigure(tuple(range(3)), weight=1)
        self.window.columnconfigure(0, weight=1)

        self.top_frame = tk.Frame(self.window)
        self.mid_frame = tk.Frame(self.window)
        self.bottom_frame = tk.Frame(self.window)

        self.top_frame.grid(row=0, column=0, sticky="news")
        self.mid_frame.grid(row=1, column=0, sticky="news")
        self.bottom_frame.grid(row=2, column=0, sticky="news")

        self.top_frame.rowconfigure(tuple(range(5)), weight=1)
        self.top_frame.columnconfigure(0, weight=1)
        self.top_frame.columnconfigure(1, weight=1)

        # Okno za izpis trenutnih nastavitev
        self.lbl_currset = tk.Label(self.top_frame, text=TEXT_CURRENT_SETTINGS, height=1)
        self.lbl_currset.grid(row=0, column=0, sticky="news")

        self.currset_status_text = tk.StringVar()
        self.msg_currset = tk.Message(self.top_frame, textvariable=self.currset_status_text, aspect=50, width=150)
        self.msg_currset.grid(row=1, column=0, rowspan=3, sticky="news")

        # Okno za izpis statusa stabilizacije
        self.stab_status_text = tk.StringVar()
        self.lbl_stab_status = tk.Label(self.top_frame, textvariable=self.stab_status_text, height=1, width=150)
        self.lbl_stab_status.grid(row=4, column=0, sticky="news")

        # Okna za interaktivno izvedbo eksperimentov
        self.chk_var = tk.IntVar()
        self.chk_btn = tk.Checkbutton(self.top_frame, text=TEXT_INTERACTIVE, variable=self.chk_var, onvalue=1, offvalue=0,
                                      command=self.click_interactive)
        self.chk_btn.grid(row=1, column=1, sticky="ew")

        self.btn_next = tk.Button(self.top_frame, text=TEXT_NEXT, command=self.click_next, state=tk.DISABLED)
        self.btn_next.grid(row=2, column=1, sticky="ew")

        self.mid_frame.rowconfigure(0, weight=1)
        self.mid_frame.columnconfigure(0, weight=2)
        self.mid_frame.columnconfigure(1, weight=1)
        self.mid_frame.columnconfigure(2, weight=1)

        # Okno za izpis obvestil
        self.listbox_log = tk.Listbox(self.mid_frame, width=100, state=tk.DISABLED)
        self.listbox_log.grid(row=0, column=0, sticky="news")
        self.scrollbar_log = tk.Scrollbar(self.mid_frame)
        self.scrollbar_log.grid(row=0, column=1, sticky="ns")
        self.listbox_log.configure(yscrollcommand=self.scrollbar_log.set)
        self.scrollbar_log.configure(command=self.listbox_log.yview)

        # Gumb za brisanje obvestil
        self.btn_clean = tk.Button(self.mid_frame, text=TEXT_CLEAR, command=self.clean_log_window)
        self.btn_clean.grid(row=0, column=2, sticky="ew")

        self.bottom_frame.rowconfigure(0, weight=1)
        self.bottom_frame.columnconfigure(0, weight=1)

        # Gumb za izstop iz aplikacije
        self.btn_quit = tk.Button(self.bottom_frame, text=TEXT_QUIT, command=self.close_window)
        self.btn_quit.grid(row=0, column=0)

        # Log dogodkov se zapisuje v csv datoteko
        self.csv_folder = DEFAULT_CSV_FOLDER  # kje se nahaja csv datoteka
        self.ir_csv_file = None  # odprta ir csv datoteka
        self.current_csv_line = ""  # nov zapis za csv datoteko

        # Statusi
        self.state = STATE_REGISTER
        self.master_id = 0
        self.request_num = 0
        self.error_status = 0

        self.active_reactor_var = 0
        self.interactive_mode = False
        self.logs_num = 0

        # Timerji
        self.waiting_slave_response_start_time = 0
        self.waiting_experiment_stability_start_time = 0
        self.stability_check_start_time = 0
        self.waiting_experiment_analysis_start_time = 0
        self.analysis_check_start_time = 0
        self.app_start_time = datetime.now().strftime('%Y_%m_%d_%H_%M_%S')

        # Nastavitve
        self.reactor_vars = []
        self.reactor_consts = []

        self.next_experiment_parameters = None
        self.experiment_stability_min_time = DEFAULT_MIN_STABILIZATION_TIME
        self.experiment_stability_MAX_time = DEFAULT_MAX_STABILIZATION_TIME
        self.experiment_stability_check_interval = DEFAULT_EXPERIMENT_STABILITY_CHECK_INTERVAL
        self.experiment_analysis_MAX_time = DEFAULT_MAX_EXPERIMENT_ANALYSIS_TIME
        self.experiment_analysis_check_interval = DEFAULT_EXPERIMENT_ANALYSIS_CHECK_INTERVAL
        self.slave_response_timeout = DEFAULT_SLAVE_RESPONSE_TIMEOUT

        self.verbose = DEFAULT_VERBOSE

        # IR
        self.ir_peaks = None
        self.ir_peaks_vals = None
        self.ir_slope_measurements = DEFAULT_IR_SLOPE_MEASUREMENTS
        self.ir_slope_threshold = DEFAULT_IR_SLOPE_THRESHOLD
        self.ir_stabilized = False

        # UPLC
        self.uplc_peaks = []
        self.uplc_peaks_area_sum = 0
        self.uplc_peaks_conc_sum = 0
        self.uplc_analysis_done = False


        # TCP client
        self.tcp_client = None
        self.waiting_for_response = False
        self.slave_host = DEFAULT_SLAVE_HOST
        self.slave_port = DEFAULT_SLAVE_PORT

        self.master_port = DEFAULT_MASTER_PORT

        # Optimizer
        self.optimizer = DEFAULT_OPTIMIZER
        self.optimizer_maximize_reactor_var = None
        self.optimizer_minimize_reactor_var = None
        self.optimizer_maximize_uplc_area = None
        self.optimizer_minimize_uplc_area = None
        self.optimizer_maximize_uplc_conc = None
        self.optimizer_minimize_uplc_conc = None
        self.optimizer_maximize_uplc_sel = None
        self.optimizer_maximize_uplc_prod = None
        self.optimizer_target_vals = None   # tukaj bodo vpisane vrednosti ciljnih spremenljivk za optimizacijo


        self.optim_thread = None
        self.optim_queue_req = queue.Queue()
        self.optim_queue_res = queue.Queue()

        self.tsemo_initial_samples_per_var = DEFAULT_TSEMO_INITIAL_SAMPLES_PER_VAR
        self.tsemo_num_of_iters = DEFAULT_TSEMO_NUM_OF_ITERATIONS
        self.tsemo_num_of_spectral_sample_points = DEFAULT_TSEMO_NUM_OF_SPECTRAL_SAMPLING_POINTS
        self.tsemo_matern_class = DEFAULT_TSEMO_MATERN_CLASS
        self.tsemo_direct_evals = DEFAULT_TSEMO_DIRECT_EVALS
        self.tsemo_ga_pop_size = DEFAULT_TSEMO_GA_POP_SIZE
        self.tsemo_ga_num_of_generations = DEFAULT_TSEMO_GA_NUM_OF_GENERATIONS
        self.tsemo_iteration_batch_size = DEFAULT_TSEMO_ITERATION_BATCH_SIZE
        self.tsemo_backup_steps = DEFAULT_TSEMO_BACKUP_STEPS

    #
    # Pomozne funkcije
    #

    # Funkcija za generiranje casovne oznake
    def util_get_time_stamp_string(self):
        return datetime.now().strftime('%d.%m.%Y %H:%M:%S')

    def util_get_curr_reactor_vars_settings_string(self, separator):
        settings = ""
        if len(self.reactor_consts) > 0:
            settings = f"{separator}".join(const.name + ":" + str(const.cur_val) for const in self.reactor_consts) + separator

        settings += f"{separator}".join(var.name + ":" + str(var.cur_val) for var in self.reactor_vars)

        return settings

#   def util_validate_indices(self, indices, defs):
#       res = True
#       if indices is not None and any(x < 1 or x > len(defs) for x in indices):
#           res = False
#       return res
#
#    def util_empty_intersection(self, indices1, indices2):
#        return not any(x in indices1 for x in indices2)




    def util_validate_indices(self, indices_lst, defs):
        for ind in indices_lst:
            if ind is not None and any(x < 1 or x > len(defs) for x in ind):
                return False
        return True

    def util_validate_intersections(self, indices_lst):
        existing = set()
        for ind in indices_lst:
            if ind is None:
                continue
            cur_set = set(ind)
            if len(cur_set & existing) > 0:
                return False
            existing |= cur_set

        return True

    #
    # Funkcije za delo z UI
    #

    # Uporabnik pritisne gumb "next"
    def click_next(self):
        assert (self.next_experiment_parameters is None)

        if self.optimizer != OPTIMIZER_NONE:
            self.chk_var.set(False)
            self.interactive_mode = False

        self.state = STATE_DESIGN_NEW_EXPERIMENT
        self.btn_next.config(state=tk.DISABLED)

    # Uporabnik spremeni vsebino potrdilnega polja "interactive"
    def click_interactive(self):
        if self.chk_var.get() == 0:
            if self.state == STATE_PAUSED_IN_INTERACTIVE_MODE:
                assert (self.next_experiment_parameters is None)
                self.state = STATE_DESIGN_NEW_EXPERIMENT
            self.btn_next.config(state=tk.DISABLED)
            self.interactive_mode = False
        else:
            self.interactive_mode = True

    # Uporabnik zeli zapreti aplikacijo
    def close_window(self):
        self.state = STATE_EXIT_PROGRAM

    # Funkcija za dodajanje zapisa v okno "log"
    def add_text_to_log_window(self, text, color, add_time_stamp=True):
        if add_time_stamp:
            text = f"{self.util_get_time_stamp_string()} {text}"

        self.listbox_log.configure(state=tk.NORMAL)
        if self.logs_num == MAX_LOGS:
            self.listbox_log.delete(0, 0)
            self.logs_num -= 1

        self.listbox_log.insert(tk.END, text)
        self.listbox_log.itemconfigure(tk.END, background=color)
        self.listbox_log.configure(tk.DISABLED)
        self.listbox_log.yview(tk.END)
        self.logs_num += 1

    # Funkcija za brisanje vseh zapisov v oknu "log"
    def clean_log_window(self):
        self.listbox_log.configure(state=tk.NORMAL)
        self.listbox_log.delete(0, tk.END)
        self.listbox_log.configure(state=tk.DISABLED)
        self.listbox_log.yview(tk.END)
        self.logs_num = 0

    # Funkcija za izpis trenutnih nastavitev parametrov eksperimenta
    def display_next_experiment_parameters(self):
        text = self.next_experiment_parameters.replace("#", "\n")
        self.currset_status_text.set(text)

    #
    # Branje nastavitev programa
    #

    def read_config_file(self, file_name):
        self.reactor_consts = []
        self.reactor_vars = []
        self.uplc_peaks = []
        self.experiment_stability_min_time = DEFAULT_MIN_STABILIZATION_TIME
        self.experiment_stability_MAX_time = DEFAULT_MAX_STABILIZATION_TIME

        # verzija skripte se za enkrat ne uporablja...
        config_ver = 1

        try:
            with open(file_name, 'r') as fp:
                for line in fp:
                    if not line.startswith("#") and line.strip():
                        line = line.split("\n")[0]
                        tokens = line.split("=", maxsplit=1)
                        command = tokens[0].strip()
                        if command == CONFIG_COMMAND_REACTOR_VAR:
                            args = tokens[1].split(',')
                            self.reactor_vars.append(
                                ReactorVar(args[0].strip(), float(args[1].strip()), float(args[2].strip()),
                                         float(args[3].strip())))
                        elif command == CONFIG_COMMAND_REACTOR_CONST:
                            args = tokens[1].split(',')
                            self.reactor_consts.append(
                                ReactorVar(args[0].strip(), float(args[1].strip()), float(args[1].strip()), 0.0))
                        elif command == CONFIG_COMMAND_REACTOR_STABILIZATION_MIN_TIME:
                            self.experiment_stability_min_time = int(tokens[1])
                        elif command == CONFIG_COMMAND_REACTOR_STABILIZATION_MAX_TIME:
                            self.experiment_stability_MAX_time = int(tokens[1])
                        elif command == CONFIG_COMMAND_EXPERIMENT_STABILITY_CHECK_INTERVAL:
                            self.experiment_stability_check_interval = int(tokens[1])
                        elif command == CONFIG_COMMAND_UPLC_RETENTION_TIME:
                            args = tokens[1].split(',')
                            self.uplc_peaks.append(
                                UPLCPeak(float(args[0].strip()), float(args[1].strip())))
                        elif command == CONFIG_COMMAND_CSV_FOLDER:
                            self.csv_folder = tokens[1].strip().replace('"', '')
                            self.csv_folder = self.csv_folder.replace('/', '\\')
                            if not self.csv_folder.endswith('\\'):
                                self.csv_folder += '\\'
                        elif command == CONFIG_COMMAND_IR_PEAKS:
                            self.ir_peaks = [float(x.strip()) for x in tokens[1].split(',')]
                            self.ir_peaks_vals = [None] * len(self.ir_peaks)
                        elif command == CONFIG_COMMAND_IR_SLOPE_MEASUREMENTS:
                            self.ir_slope_measurements = int(tokens[1])
                        elif command == CONFIG_COMMAND_IR_SLOPE_THRESHOLD:
                            self.ir_slope_threshold = float(tokens[1])
                        elif command == CONFIG_COMMAND_EXPERIMENT_ANALYSIS_MAX_TIME:
                            self.experiment_analysis_MAX_time = int(tokens[1])
                        elif command == CONFIG_COMMAND_LOG_LEVEL:
                            log_level = int(tokens[1])
                            if log_level == 1:
                                logger.setLevel(logging.DEBUG)
                            elif log_level == 2:
                                logger.setLevel(logging.INFO)
                            elif log_level == 3:
                                logger.setLevel(logging.WARNING)
                            elif log_level == 4:
                                logger.setLevel(logging.ERROR)
                            elif log_level == 5:
                                logger.setLevel(logging.CRITICAL)
                            else:
                                messagebox.showerror("Napaka", "vrednost LOG_LEVEL mora biti med 1 in 5.")
                        elif command == CONFIG_COMMAND_SLAVE_RESPONSE_TIMEOUT:
                            self.slave_response_timeout = int(tokens[1])
                        elif command == CONFIG_COMMAND_SLAVE_URL:
                            args = tokens[1].split(':')
                            self.slave_host = args[0].strip().replace('"', '')
                            self.slave_port = int(args[1].strip().replace('"', ''))
                        elif command == CONFIG_COMMAND_MASTER_PORT:
                            self.master_port = int(tokens[1])
                        elif command == CONFIG_COMMAND_OPTIMIZER:
                            optimizer_name = tokens[1].strip()
                            if optimizer_name == OPTIMIZER_TSEMO:
                                self.optimizer = OPTIMIZER_TSEMO
                            elif optimizer_name == OPTIMIZER_NONE:
                                self.optimizer = OPTIMIZER_NONE
                            else:
                                logtext = f"Neznan optimizator"
                                logger.critical(logtext)
                                messagebox.showerror("Napaka", logtext)
                                sys.exit(1)
                        elif command == CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_REACTOR_VAR:
                            self.optimizer_maximize_reactor_var = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_OPTIMIZER_MINIMIZE_REACTOR_VAR:
                            self.optimizer_minimize_reactor_var = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_AREA:
                            self.optimizer_maximize_uplc_area = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_OPTIMIZER_MINIMIZE_UPLC_AREA:
                            self.optimizer_minimize_uplc_area = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_CONC:
                            self.optimizer_maximize_uplc_conc = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_OPTIMIZER_MINIMIZE_UPLC_CONC:
                            self.optimizer_minimize_uplc_conc = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_SEL:
                            self.optimizer_maximize_uplc_sel = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_OPTIMIZER_MAXIMIZE_UPLC_PROD:
                            self.optimizer_maximize_uplc_prod = [int(x.strip()) for x in tokens[1].split(',')]
                        elif command == CONFIG_COMMAND_TSEMO_INITIAL_SAMPLES_PER_VAR:
                            self.tsemo_initial_samples_per_var = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_NUM_OF_ITERATIONS:
                            self.tsemo_num_of_iters = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_NUM_OF_SPECTRAL_SAMPLING_POINTS:
                            self.tsemo_num_of_spectral_sample_points = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_MATERN_CLASS:
                            self.tsemo_matern_class = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_DIRECT_EVALS:
                            self.tsemo_direct_evals = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_GA_POP_SIZE:
                            self.tsemo_ga_pop_size = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_GA_NUM_OF_GENERATIONS:
                            self.tsemo_ga_num_of_generations = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_ITERATION_BATCH_SIZE:
                            self.tsemo_iteration_batch_size = int(tokens[1])
                        elif command == CONFIG_COMMAND_TSEMO_BACKUP_STEPS:
                            self.tsemo_backup_steps = int(tokens[1])
                        elif command == CONFIG_COMMAND_FILE_VER:
                            config_ver = int(tokens[1])
                            if config_ver != 1:
                                messagebox.showerror("Napaka", "Neznana verzija skripte")
                                sys.exit(1)
                        else:
                            logtext = f"Neznan ukaz {command} v konfiguracijski datoteki!"
                            logger.critical(logtext)
                            messagebox.showerror("Napaka", logtext)
                            sys.exit(1)
        except FileNotFoundError:
            logtext = f"Ne najdem datoteke {file_name}"
            logger.critical(logtext)
            messagebox.showerror("Napaka", logtext)
            sys.exit(1)
        except IOError:
            logtext = f"Ne morem prebrati datoteke {file_name}"
            logger.critical(logtext)
            messagebox.showerror("Napaka", logtext)
            sys.exit(1)
        except (IndexError, ValueError):
            logtext = f"Napaka v konfiguracijski datoteki (vrstica: {line})."
            logger.critical(logtext)
            messagebox.showerror("Napaka", logtext)
            sys.exit(1)
        else:
            if len(self.reactor_vars) == 0:
                logtext = f"Ni spremenljivk v konfiguracijski datoteki {file_name}."
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif len(self.uplc_peaks) == 0:
                logtext = f"Ni definitanih intervalov za UPLC retention time v konfiguracijski datoteki {file_name}."
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif self.optimizer != OPTIMIZER_NONE and \
                    self.optimizer_maximize_uplc_area is None and \
                    self.optimizer_minimize_uplc_area is None and \
                    self.optimizer_maximize_uplc_conc is None and \
                    self.optimizer_minimize_uplc_conc is None and \
                    self.optimizer_maximize_uplc_sel is None and \
                    self.optimizer_maximize_uplc_prod is None:
                logtext = f"Niso definirane ciljne funkcije."
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif self.optimizer_maximize_uplc_sel is not None and len(self.optimizer_maximize_uplc_sel) > 1:
                logtext = f"Samo en indeks je dovoljen za maksimizacijo selektivnosti UPLC vrhov"
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif self.optimizer_maximize_uplc_prod is not None and len(self.optimizer_maximize_uplc_prod) > 1:
                logtext = f"Samo en indeks je dovoljen za maksimizacijo produktivnosti UPLC vrhov"
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif not self.util_validate_indices([self.optimizer_maximize_reactor_var, self.optimizer_minimize_reactor_var], self.reactor_vars):
                logtext = f"Nepravilni indeksi v ukazih za maksimizacijo oz. minimizacijo reaktorskih spremenljivk"
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif not self.util_validate_indices([self.optimizer_maximize_uplc_area,
                                                 self.optimizer_minimize_uplc_area,
                                                 self.optimizer_maximize_uplc_conc,
                                                 self.optimizer_minimize_uplc_conc,
                                                 self.optimizer_maximize_uplc_sel,
                                                 self.optimizer_maximize_uplc_prod], self.uplc_peaks):
                logtext = f"Nepravilni indeksi v ukazih za maksimizacijo oz. minimizacijo UPLC vrhov"
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif not self.util_validate_intersections([self.optimizer_maximize_reactor_var, self.optimizer_minimize_reactor_var]):
                logtext = f"Nekateri indeksi se ponavljajo v ukazih za maksimizacijo oz. minimizacijo reaktorskih spremenljivk"
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            elif not self.util_validate_intersections([self.optimizer_maximize_uplc_area, self.optimizer_minimize_uplc_area,
                                                       self.optimizer_maximize_uplc_conc, self.optimizer_minimize_uplc_conc,
                                                       self.optimizer_maximize_uplc_sel, self.optimizer_maximize_uplc_prod]):
                logtext = f"Nekateri indeksi se ponavljajo v ukazih za maksimizacijo oz. minimizacijo UPLC vrhov"
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)
            else:
                logtext = f"Prebrana nastavitvena datoteka \"{file_name}\"."
                logger.info(logtext)
                self.add_text_to_log_window(logtext, "white", True)

    #
    # Funkcije za delo z csv datoteko
    #

    # Ustvari novo csv datoteko
    def create_ir_csv_file(self):
        file_name = self.csv_folder + "log_ir_" + self.app_start_time + ".csv"

        try:
            if not os.path.exists(self.csv_folder):
                os.makedirs(self.csv_folder)

            self.ir_csv_file = open(file_name, "w")

            header = "StartTime,"

            if len(self.reactor_consts) > 0:
                header += ",".join(const.name for const in self.reactor_consts) + ","

            header += ",".join(var.name for var in self.reactor_vars) + ",ErrorStatus,StopTime," + ",".join([f"Peak_{int(i)}" for i in self.ir_peaks]) + "\n"
            self.ir_csv_file.write(header)
            logtext = f"Kreirana csv datoteka \"{file_name}\""
            logger.info(logtext)
            self.add_text_to_log_window(logtext, "white", True)
        except:
            logtext = f"Ne morem odpreti csv datoteke \"{file_name}\""
            logger.critical(logtext)
            messagebox.showerror("Napaka", logtext)
            sys.exit(1)

    # Dodaj podatke o zacetku eksperimenta v tekoco vrstico
    def init_current_csv_line(self):
        time_now = datetime.now().strftime('%Y_%m_%d_%H_%M_%S')
        self.current_csv_line = time_now + ","
        if len(self.reactor_consts) > 0:
            self.current_csv_line += ",".join(str(const.cur_val) for const in self.reactor_consts) + ","
        self.current_csv_line += ",".join(str(var.cur_val) for var in self.reactor_vars) + "," + str(self.error_status)

    # Dodaj podatke po zakljucenem eksperimentu v tekoco vrstico
    def complete_current_csv_line(self):
        time_now = datetime.now().strftime('%Y_%m_%d_%H_%M_%S')
        vals = ",".join(str(val) for val in self.ir_peaks_vals)
        self.current_csv_line = f"{self.current_csv_line},{time_now},{vals}\n"

    # Dodaj tekoco vrstico v odprto csv datoteko
    def append_ir_csv_file(self):
        try:
            self.ir_csv_file.write(self.current_csv_line)
        except IOError as e:
            print("I/O error({0}): {1}".format(e.errno, e.strerror))
            logtext = "Napaka pri zapisovanju nove vrstice v csv datoteko!"
            logger.error(logtext)
            self.add_text_to_log_window(logtext, "red", True)
        except Exception as e:
            print(e)
            logtext = "Napaka pri zapisovanju nove vrstice v csv datoteko!"
            logger.error(logtext)
            self.add_text_to_log_window(logtext, "red", True)
        finally:
            self.current_csv_line = ""

    #
    # Funkcije za izbiro naslednjega eksperimenta
    #

    # funkcija za sistematicno izbiro nastavitev parametrov za naslednji eksperiment
    def setup_next_experiment(self):
        if self.optimizer == OPTIMIZER_TSEMO:
            try:
                data = self.optim_queue_req.get_nowait()

                if data['desc'] == THREAD_MSG_INFO:
                    logtext = data['value']
                    logger.info(logtext)
                    self.add_text_to_log_window(logtext, "green", True)

                elif data['desc'] == THREAD_MSG_POINT:
                    exp_setting = data['value']
                    for i in range(len(exp_setting)):
                        self.reactor_vars[i].set_val(exp_setting[i])

                    self.next_experiment_parameters = self.util_get_curr_reactor_vars_settings_string("#")
                    self.display_next_experiment_parameters()
                    self.init_current_csv_line()
                    self.error_status = 0
                    self.state = STATE_INITIATE_NEW_EXPERIMENT
                    logtext = "Zacetek novega eksperimenta."
                    logger.info(logtext)
                    self.add_text_to_log_window(logtext, "magenta")
                elif data['desc'] == THREAD_MSG_RESULT:
                    retVal = data['value']
                    if retVal['Succeed']:
                        self.stab_status_text.set("Optimizacija je končana!")

                        logtext = "Postopek optimizacije je uspesno zakljucen."
                        logger.info(logtext)
                        self.add_text_to_log_window(logtext, "green")

                        self.state = STATE_SERIES_OF_EXPERIMENTS_COMPLETED
                        self.write_tsemo_result_to_file(retVal)
                        self.plot_tsemo_result(retVal)
                    else:
                        self.stab_status_text.set(f"Napaka v postopku optimizacije! {retVal['Desc']}")

                        logtext = "Postopek optimizacije je prekinjen."
                        logger.info(logtext)
                        self.add_text_to_log_window(logtext, "red")

                        self.state = STATE_SERIES_OF_EXPERIMENTS_COMPLETED
            except queue.Empty:
                pass

        elif self.optimizer == OPTIMIZER_NONE:
            if not self.reactor_vars[self.active_reactor_var].is_over_end():
                if self.active_reactor_var == len(self.reactor_vars) - 1:
                    self.next_experiment_parameters = self.util_get_curr_reactor_vars_settings_string("#")
                    self.display_next_experiment_parameters()
                    self.init_current_csv_line()
                    self.error_status = 0
                    self.state = STATE_INITIATE_NEW_EXPERIMENT
                    logtext = "Zacetek novega eksperimenta."
                    logger.info(logtext)
                    self.add_text_to_log_window(logtext, "magenta")

                if self.active_reactor_var < len(self.reactor_vars) - 1:
                    self.active_reactor_var += 1
                    self.reactor_vars[self.active_reactor_var].reset_val()
                else:
                    self.reactor_vars[self.active_reactor_var].increment_val()
            else:
                self.reactor_vars[self.active_reactor_var].reset_val()
                if self.active_reactor_var > 0:
                    self.active_reactor_var -= 1
                    self.reactor_vars[self.active_reactor_var].increment_val()
                else:
                    self.stab_status_text.set("Postopek je končan!")
                    self.state = STATE_SERIES_OF_EXPERIMENTS_COMPLETED

    #
    # Cakanje v interaktivnem nacinu
    #

    def wait_in_interactive_mode(self):
        pass

    #
    # Cakanje na stabilizacijo eksperimenta
    #

    def check_experiment_stabilization_timeout(self):
        assert (self.state == STATE_CHECK_EXPERIMENT_STABILITY)

        time_elapsed = time.time() - self.waiting_experiment_stability_start_time

        waiting_is_over = False

        if time_elapsed >= self.experiment_stability_MAX_time:
            self.stab_status_text.set("Čas za stabilizacijo je potekel!")
            logtext = "Eksperiment je koncan. Maksimalen cas za stabilizacijo je potekel."
            logger.warning(logtext)
            self.add_text_to_log_window(logtext, "magenta", True)
            waiting_is_over = True
        elif time_elapsed >= self.experiment_stability_min_time and self.ir_stabilized:
            self.stab_status_text.set("IR meritve so stabilne!")
            logtext = "Eksperiment je koncan. IR meritve so stabilne."
            logger.info(logtext)
            self.add_text_to_log_window(logtext, "magenta", True)
            waiting_is_over = True

        # ce je cas potekel
        if waiting_is_over:
            # eksperiment je zakljucen, dodaj zapis v csv datoteko
            self.complete_current_csv_line()
            self.append_ir_csv_file()

            # potrebno je sproziti analizo eksperimenta
            self.state = STATE_INITIATE_EXPERIMENT_ANALYSIS
        else:
            # posodobi cas do konca cakanja na stabilizacijo
            self.stab_status_text.set(
                f"Čas do stabilizacije: {round(self.experiment_stability_MAX_time - time_elapsed + 0.5)}!")

    #
    # Cakanje na analizo eksperimenta
    #
    def check_experiment_analysis_timeout(self):
        assert (self.state == STATE_CHECK_EXPERIMENT_ANALYSIS)

        time_elapsed = time.time() - self.waiting_experiment_analysis_start_time

        waiting_is_over = False

        # Kako oznacimo tole?

        if time_elapsed >= self.experiment_analysis_MAX_time:
            self.stab_status_text.set("Čas za analizo je potekel!")
            logtext = "Maksimalen cas za analizo reakcije je potekel."
            logger.warning(logtext)
            self.add_text_to_log_window(logtext, "magenta", True)
            waiting_is_over = True
        elif self.uplc_analysis_done:
            self.stab_status_text.set("Analiza reakcije je zakljucena!")
            logtext = "Analiza reakcije je zakljucena."
            logger.info(logtext)
            self.add_text_to_log_window(logtext, "magenta", True)
            waiting_is_over = True
            self.uplc_analysis_done = False

        # ce je cas potekel
        if waiting_is_over:
            # analiza eksperimenta je zakljucena, dodaj zapis v csv datoteko?

            # TODO TODO TODO
            # TODO TODO TODO
            # TODO TODO TODO Ali dodamo v nek csv tudi rezultat UPLC analize?
            # TODO TODO TODO
            # TODO TODO TODO

            # self.complete_current_csv_line()
            # self.append_ir_csv_file()

            if self.optimizer == OPTIMIZER_TSEMO:
                # rezultat UPLC analize
                result = np.array([])

                tmp = np.array([peak.area for peak in self.uplc_peaks])

                if self.optimizer_maximize_uplc_sel is not None:
                    result = np.concatenate((result, tmp[self.optimizer_maximize_uplc_sel] / self.uplc_peaks_area_sum))
                if self.optimizer_minimize_uplc_area is not None:
                    result = np.concatenate((result, tmp[self.optimizer_minimize_uplc_area]))
                if self.optimizer_maximize_uplc_area is not None:
                    result = np.concatenate((result, -1 * tmp[self.optimizer_maximize_uplc_area]))

                tmp = np.array([peak.conc for peak in self.uplc_peaks])

                if self.optimizer_maximize_uplc_prod is not None:
                    result = np.concatenate((result, tmp[self.optimizer_maximize_uplc_prod] / self.uplc_peaks_conc_sum))
                if self.optimizer_minimize_uplc_conc is not None:
                    result = np.concatenate((result, tmp[self.optimizer_minimize_uplc_conc]))
                if self.optimizer_maximize_uplc_conc is not None:
                    result = np.concatenate((result, -1 * tmp[self.optimizer_maximize_uplc_conc]))

                tmp = np.array([var.cur_val for var in self.reactor_vars])

                if self.optimizer_minimize_reactor_var is not None:
                    result = np.concatenate((result, tmp[self.optimizer_minimize_reactor_var]))
                if self.optimizer_maximize_reactor_var is not None:
                    result = np.concatenate((result, -1 * tmp[self.optimizer_maximize_reactor_var]))


                if FAKE_DATA:
                    result = result * (random.random() + 0.5)

                data = {
                    'value': result,
                    'desc': THREAD_MSG_RESULT
                }
                self.optim_queue_res.put(data)

            # odstrani nastavitve zakljucenega eksperimenta
            self.next_experiment_parameters = None

            # preveri, ali uporabnik zeli interaktivni nacin
            if self.interactive_mode:
                self.state = STATE_PAUSED_IN_INTERACTIVE_MODE
                self.btn_next.config(state=tk.ACTIVE)
            else:
                # potrebno bo izbrati nastavitve za nov eksperiment
                self.state = STATE_DESIGN_NEW_EXPERIMENT
        else:
            # posodobi cas do konca cakanja na stabilizacijo
            self.stab_status_text.set(
                f"Čas do konca analize: {round(self.experiment_analysis_MAX_time - time_elapsed + 0.5)}!")


    #
    # Funkcije za pripravo zahtev za slave aplikacijo
    #

    def create_request_register_master(self):
        return f"{self.request_num}:{self.master_id}:{PROTOCOL_COMMAND_REG}"

    def create_request_set_ir_settings(self):
        peaks_str = ",".join(str(x) for x in self.ir_peaks)
        return f"{self.request_num}:{self.master_id}:{PROTOCOL_COMMAND_SET_IR}#{PROTOCOL_ATTR_PKS}:{peaks_str}#{PROTOCOL_ATTR_SM}:{self.ir_slope_measurements}#{PROTOCOL_ATTR_ST}:{self.ir_slope_threshold}"

    def create_request_set_reactor_settings(self):
        return f"{self.request_num}:{self.master_id}:{PROTOCOL_COMMAND_SET_REACTOR_VARS}#{self.next_experiment_parameters}"

    def create_request_query_is_stable(self):
        return f"{self.request_num}:{self.master_id}:{PROTOCOL_COMMAND_CHECK_STABILITY}"

    def create_request_initiate_analysis(self):
        return f"{self.request_num}:{self.master_id}:{PROTOCOL_COMMAND_START_ANALYSIS}"

    def create_request_query_analysis_results(self):
        return f"{self.request_num}:{self.master_id}:{PROTOCOL_COMMAND_CHECK_ANALYSIS}"


    def send_request(self):
        if self.waiting_for_response:
            return

        request = None
        self.request_num = self.request_num + 1

        if self.state == STATE_REGISTER:
            request = self.create_request_register_master()
        elif self.state == STATE_SET_IR_SETTINGS:
            request = self.create_request_set_ir_settings()
        elif self.state == STATE_INITIATE_NEW_EXPERIMENT:
            request = self.create_request_set_reactor_settings()
        elif self.state == STATE_CHECK_EXPERIMENT_STABILITY:
            if round(
                    self.experiment_stability_check_interval - time.time() + self.stability_check_start_time + 0.5) <= 0:
                request = self.create_request_query_is_stable()
        elif self.state == STATE_INITIATE_EXPERIMENT_ANALYSIS:
            request = self.create_request_initiate_analysis()
        elif self.state == STATE_CHECK_EXPERIMENT_ANALYSIS:
            if round(
                    self.experiment_analysis_check_interval - time.time() + self.analysis_check_start_time + 0.5) <= 0:
                request = self.create_request_query_analysis_results()
        if request is not None:
            self.tcp_client = TCPClient(self.slave_host, self.slave_port, self.master_port, request)
            self.waiting_slave_response_start_time = time.time()
            self.waiting_for_response = True
            if self.state == STATE_INITIATE_NEW_EXPERIMENT:
                self.waiting_experiment_stability_start_time = time.time()
            elif self.state == STATE_CHECK_EXPERIMENT_STABILITY:
                self.stability_check_start_time = time.time()
            elif self.state == STATE_INITIATE_EXPERIMENT_ANALYSIS:
                self.waiting_experiment_analysis_start_time = time.time()
            elif self.state == STATE_CHECK_EXPERIMENT_ANALYSIS:
                self.analysis_check_start_time = time.time()
    #
    # Funkcije za obdelavo prejetega odgovora s strani slave aplikacije
    #

    # Funkcija preveri, ali smo predolgo cakali na odgovor
    def check_response_timeout(self):
        assert (self.waiting_for_response)

        waiting_is_over = round(
            self.slave_response_timeout - time.time() + self.waiting_slave_response_start_time + 0.5) <= 0

        if waiting_is_over:
            if self.tcp_client is not None:
                self.tcp_client.shut_down()
            self.waiting_for_response = False

    # Funkcija obdela prejeti odgovor
    def process_received_response(self, response):
        tokens = response.split("#")

        try:
            params = tokens[0].split(":")
            request_num = int(params[0])
            master_id = int(params[1])
            result = params[2]

            if request_num == self.request_num and master_id == self.master_id:
                if result == PROTOCOL_RESULT_PROTOCOL_ERROR:
                    logtext = "Napaka v komunikaciji s FaustoSlave aplikacijo (Protocol error)."
                    logger.warning(logtext)
                    self.add_text_to_log_window(logtext, "yellow", True)
                    self.state = STATE_REGISTER

                elif result == PROTOCOL_RESULT_SYNTAX_ERROR:
                    logtext = "Napaka v komunikaciji s FaustoSlave aplikacijo (Syntax error)."
                    logger.warning(logtext)
                    self.add_text_to_log_window(logtext, "yellow", True)
                    # TODO: kaj v tem primeru? Za enkrat se isti ukaz ponovi...

                elif self.state == STATE_REGISTER and result == PROTOCOL_RESULT_OK:
                    logtext = "Uspesna registracija na FaustoSlave aplikaciji."
                    logger.info(logtext)
                    self.add_text_to_log_window(logtext, "white", True)
                    self.state = STATE_SET_IR_SETTINGS

                elif self.state == STATE_SET_IR_SETTINGS and result == PROTOCOL_RESULT_OK:
                    logtext = "Nastavitve za IR uspesno poslane FaustoSlave aplikaciji."
                    logger.info(logtext)
                    self.add_text_to_log_window(logtext, "white", True)
                    if self.next_experiment_parameters is None:
                        self.state = STATE_DESIGN_NEW_EXPERIMENT
                    else:
                        self.state = STATE_INITIATE_NEW_EXPERIMENT

                elif self.state == STATE_INITIATE_NEW_EXPERIMENT and result == PROTOCOL_RESULT_OK:
                    logtext = "Nastavitve parametrov za izvedbo eksperimenta uspesno poslane FaustoSlave aplikaciji."
                    logger.info(logtext)
                    self.add_text_to_log_window(logtext, "white", True)
                    self.waiting_experiment_stability_start_time = time.time()
                    self.state = STATE_CHECK_EXPERIMENT_STABILITY

                elif self.state == STATE_CHECK_EXPERIMENT_STABILITY:
                    stable = (result == PROTOCOL_RESULT_YES)
                    for i in range(len(self.ir_peaks_vals)):
                        if params[3 + i] == "None":
                            self.ir_peaks_vals[i] = ""
                        else:
                            self.ir_peaks_vals[i] = float(params[3 + i])
                    self.ir_stabilized = stable

                elif self.state == STATE_INITIATE_EXPERIMENT_ANALYSIS and result == PROTOCOL_RESULT_OK:
                    logtext = "Zahteva za izvedbo analize eksperimenta uspesno poslane FaustoSlave aplikaciji."
                    logger.info(logtext)
                    self.add_text_to_log_window(logtext, "white", True)
                    self.waiting_experiment_analysis_start_time = time.time()
                    self.state = STATE_CHECK_EXPERIMENT_ANALYSIS

                elif self.state == STATE_CHECK_EXPERIMENT_ANALYSIS:
                    analysis_done = (result == PROTOCOL_RESULT_YES)

                    if analysis_done:
                        for peak in self.uplc_peaks:
                            peak.set_zero()

                        self.uplc_peaks_area_sum = 0
                        self.uplc_peaks_conc_sum = 0

                        for i in range(1, len(tokens)):
                            vals = tokens[i].split(":")

                            # TODO preveri, ali res dobis tri vrednosti. Sporoci napako, ce jih je vec ali manj kot 3

                            time_val = float(vals[0])
                            area_val = float(vals[1])
                            conc_val = float(vals[2])

                            for peak in self.uplc_peaks:
                                peak.set_val(time_val, area_val, conc_val)

                            self.uplc_peaks_area_sum += area_val
                            self.uplc_peaks_conc_sum += conc_val

                    self.uplc_analysis_done = analysis_done
            else:
                logtext = "Prejet odgovor od FaustoSlave aplikacije izven konteksta."
                logger.warning(logtext)
                self.add_text_to_log_window(logtext, "yellow", True)
                self.state = STATE_REGISTER


        except (IndexError, ValueError):
            pass

    #
    # Funkcija za periodicno obdelavo vseh dogodkov
    #
    def periodic_callback(self):
        # najprej obdelaj tcp dogodke
        if self.tcp_client is not None:
            connected, response = self.tcp_client.process_socket_events()

            # preveri, ali smo prejeli odgovor od FaustoSlave32 aplikacije
            if response is not None:
                self.process_received_response(response)
                self.waiting_for_response = False

            # preveri, ali se vedno imamo povezavo
            if not connected:
                self.tcp_client.shut_down()
                self.tcp_client = None

        # preveri, ali uporabnik zapira aplikacijo
        if self.state == STATE_EXIT_PROGRAM:
            try:
                self.window.quit()
                self.window.destroy()
            except:
                pass
            finally:
                pass
        else:
            # ali smo v interaktivnem nacinu
            if self.state == STATE_PAUSED_IN_INTERACTIVE_MODE:
                self.wait_in_interactive_mode()
            # ali zelimo pognati nov eksperiment
            elif self.state == STATE_DESIGN_NEW_EXPERIMENT:
                self.setup_next_experiment()
            else:
                # preveri, ali predolgo cakamo na stabilnost reakcije
                if self.state == STATE_CHECK_EXPERIMENT_STABILITY:
                    self.check_experiment_stabilization_timeout()

                # preveri, ali predolgo cakamo na analizo reakcije
                if self.state == STATE_CHECK_EXPERIMENT_ANALYSIS:
                    self.check_experiment_analysis_timeout()

                # preveri, ali predolgo cakamo odgovor od slave aplikacije
                if self.waiting_for_response:
                    self.check_response_timeout()

                # preveri, ali zelimo poslati nov ukaz slave aplikaciji
                if not self.waiting_for_response:
                    self.send_request()

            # cez sekundo (desetinko) ponovno poklici callback
            self.window.after(1000, self.periodic_callback)

    def start_processing(self):
        self.read_config_file("config_master.txt")
        self.create_ir_csv_file()

        self.master_id = int(time.time() * 1000)
        self.request_num = 0
        self.state = STATE_REGISTER

        if self.optimizer == OPTIMIZER_NONE:
            self.chk_btn.config(text=TEXT_INTERACTIVE)
            self.btn_next.config(text=TEXT_NEXT)
        else:
            self.chk_btn.config(text=TEXT_MAINTENANCE)
            self.btn_next.config(text=TEXT_CONTINUE)


        self.btn_next.config(state=tk.DISABLED)

        num_outputs = 0
        # uporabljali bomo indeksno naslavljanje, zato znizamo vrednosti za 1

        if self.optimizer_maximize_uplc_sel is not None:
            self.optimizer_maximize_uplc_sel = np.array(self.self.optimizer_maximize_uplc_sel) - 1
            num_outputs += len(self.self.optimizer_maximize_uplc_sel)

        if self.optimizer_minimize_uplc_area is not None:
            self.optimizer_minimize_uplc_area = np.array(self.optimizer_minimize_uplc_area) - 1
            num_outputs += len(self.optimizer_minimize_uplc_area)

        if self.optimizer_maximize_uplc_area is not None:
            self.optimizer_maximize_uplc_area = np.array(self.optimizer_maximize_uplc_area) - 1
            num_outputs += len(self.optimizer_maximize_uplc_area)

        if self.optimizer_maximize_uplc_prod is not None:
            self.optimizer_maximize_uplc_prod = np.array(self.self.optimizer_maximize_uplc_prod) - 1
            num_outputs += len(self.self.optimizer_maximize_uplc_prod)

        if self.optimizer_minimize_uplc_conc is not None:
            self.optimizer_minimize_uplc_conc = np.array(self.optimizer_minimize_uplc_conc) - 1
            num_outputs += len(self.optimizer_minimize_uplc_conc)

        if self.optimizer_maximize_uplc_conc is not None:
            self.optimizer_maximize_uplc_conc = np.array(self.optimizer_maximize_uplc_conc) - 1
            num_outputs += len(self.optimizer_maximize_uplc_conc)

        if self.optimizer_maximize_reactor_var is not None:
            self.optimizer_maximize_reactor_var = np.array(self.optimizer_maximize_reactor_var) - 1
            num_outputs += len(self.optimizer_maximize_reactor_var)

        if self.optimizer_minimize_reactor_var is not None:
            self.optimizer_minimize_reactor_var = np.array(self.optimizer_minimize_reactor_var) - 1
            num_outputs += len(self.optimizer_minimize_reactor_var)

        obj_names = self.util_get_objective_names()

        # parametri za OptimizerThread
        thread_params = {
            'log_file_name': self.csv_folder + "log_tsemo_" + self.app_start_time + ".txt",
            'backup_steps': self.tsemo_backup_steps,
            'backup_folder': self.csv_folder + "backup\\",
            'backup_name': self.app_start_time,
            'backup_header': ",".join(var.name for var in self.reactor_vars) + "," + ",".join(obj for obj in obj_names) + "\n",
            'num_inputs': len(self.reactor_vars),
            'num_outputs': num_outputs,
            'lower_bounds': [var.min_val for var in self.reactor_vars],
            'upper_bounds': [var.max_val for var in self.reactor_vars],
            'optim_queue_req': self.optim_queue_req,
            'optim_queue_res': self.optim_queue_res,
            'tsemo_initial_samples_per_var': self.tsemo_initial_samples_per_var,
            'tsemo_num_of_iters': self.tsemo_num_of_iters,
            'tsemo_num_of_spectral_sample_points': self.tsemo_num_of_spectral_sample_points,
            'tsemo_matern_class': self.tsemo_matern_class,
            'tsemo_direct_evals': self.tsemo_direct_evals,
            'tsemo_ga_pop_size': self.tsemo_ga_pop_size,
            'tsemo_ga_num_of_generations': self.tsemo_ga_num_of_generations,
            'tsemo_iteration_batch_size': self.tsemo_iteration_batch_size
        }

        self.optim_thread = OptimizerThread(thread_params)
        self.optim_thread.daemon = True
        self.optim_thread.start()

        self.periodic_callback()

    def shut_down(self):
        if self.tcp_client is not None:
            self.tcp_client.shut_down()

        if self.ir_csv_file is not None:
            try:
                self.ir_csv_file.close()
            except:
                logtext = "Napaka pri zapiranju ir csv datoteke!"
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)

    #
    # Funkcije za izris rezultata
    #

    def util_visualize3DData(self, window, X, axis_labels):
        fig = Figure()
        canvas = FigureCanvasTkAgg(fig, master=window)
        canvas.draw()

        ax = fig.add_subplot(111, projection='3d')
        ax.scatter(X[:, 0], X[:, 1], X[:, 2], depthshade=True, picker=True)
        ax.set_xlabel(axis_labels[0])
        ax.set_ylabel(axis_labels[1])
        ax.set_zlabel(axis_labels[2])

        toolbar = NavigationToolbar2Tk(canvas, window)
        toolbar.update()

        def distance(point, event):
            assert point.shape == (3,), "distance: point.shape is wrong: %s, must be (3,)" % point.shape

            # Project 3d data space to 2d data space
            x2, y2, _ = proj3d.proj_transform(point[0], point[1], point[2], ax.get_proj())
            # Convert 2d data space to 2d screen space
            x3, y3 = ax.transData.transform((x2, y2))

            return np.sqrt((x3 - event.x) ** 2 + (y3 - event.y) ** 2)

        def calcClosestDatapoint(X, event):
            distances = [distance(X[i, 0:3], event) for i in range(X.shape[0])]
            return np.argmin(distances)

        def annotatePlot(X, index):
            # If we have previously displayed another label, remove it first
            if hasattr(annotatePlot, 'label'):
                annotatePlot.label.remove()
            # Get data point from array of points X, at position index
            x2, y2, _ = proj3d.proj_transform(X[index, 0], X[index, 1], X[index, 2], ax.get_proj())
            annotatePlot.label = ax.annotate(f"{X[index, 0]:.2f}, {X[index, 1]:.2f}, {X[index, 2]:.2f}",
                                              xy=(x2, y2), xytext=(-20, 20), textcoords='offset points', ha='right',
                                              va='bottom',
                                              bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),
                                              arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
            canvas.draw()

        def onMouseMotion(event):
            """Event that is triggered when mouse is moved. Shows text annotation over data point closest to mouse."""
            closestIndex = calcClosestDatapoint(X, event)
            annotatePlot(X, closestIndex)

        canvas.mpl_connect('motion_notify_event', onMouseMotion)  # on mouse motion

        toolbar.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

    def util_visualize2DData(self, window, X, axis_labels):
        fig = Figure()
        canvas = FigureCanvasTkAgg(fig, master=window)
        canvas.draw()

        ax = fig.add_subplot()
        ax.scatter(X[:, 0], X[:, 1], picker=True)
        ax.set_xlabel(axis_labels[0])
        ax.set_ylabel(axis_labels[1])

        toolbar = NavigationToolbar2Tk(canvas, window)
        toolbar.update()

        def distance(point, event):
            assert point.shape == (2,), "distance: point.shape is wrong: %s, must be (2,)" % point.shape
            return np.sqrt((point[0] - event.xdata) ** 2 + (point[1] - event.ydata) ** 2)

        def calcClosestDatapoint(X, event):
            distances = [distance(X[i, 0:2], event) for i in range(X.shape[0])]
            return np.argmin(distances)

        def annotatePlot(X, index):
            # If we have previously displayed another label, remove it first
            if hasattr(annotatePlot, 'label'):
                annotatePlot.label.remove()
            # Get data point from array of points X, at position index
            annotatePlot.label = ax.annotate(f"{X[index, 0]:.2f}, {X[index, 1]:.2f}",
                                              xy=(X[index, 0], X[index, 1]), xytext=(-20, 20),
                                              textcoords='offset points', ha='right', va='bottom',
                                              bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),
                                              arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
            canvas.draw()

        def onMouseMotion(event):
            """Event that is triggered when mouse is moved. Shows text annotation over data point closest to mouse."""
            if event.inaxes is None:
                return

            closestIndex = calcClosestDatapoint(X, event)
            annotatePlot(X, closestIndex)

        canvas.mpl_connect('motion_notify_event', onMouseMotion)  # on mouse motion
        toolbar.pack(side=tk.BOTTOM, fill=tk.X)
        canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)


    def util_get_objective_names(self):
        result = []

        tmp = np.array([round((peak.max_time + peak.min_time)/2, 3) for peak in self.uplc_peaks])

        if self.optimizer_maximize_uplc_sel is not None:
            result = result + [f"UPLC_MAX_SEL_{tmp[self.optimizer_maximize_uplc_sel]}"]
        if self.optimizer_minimize_uplc_area is not None:
            result = result + ["UPLC_MIN_AREA_" + str(val) for val in tmp[self.optimizer_minimize_uplc_area]]
        if self.optimizer_maximize_uplc_area is not None:
            result = result + ["UPLC_MAX_AREA_" + str(val) for val in tmp[self.optimizer_maximize_uplc_area]]

        if self.optimizer_maximize_uplc_prod is not None:
            result = result + [f"UPLC_MAX_PROD_{tmp[self.optimizer_maximize_uplc_prod]}"]
        if self.optimizer_minimize_uplc_conc is not None:
            result = result + ["UPLC_MIN_CONC_" + str(val) for val in tmp[self.optimizer_minimize_uplc_conc]]
        if self.optimizer_maximize_uplc_conc is not None:
            result = result + ["UPLC_MAX_CONC_" + str(val) for val in tmp[self.optimizer_maximize_uplc_conc]]

        tmp = np.array([var.name for var in self.reactor_vars])

        if self.optimizer_minimize_reactor_var is not None:
            result = result + ["VAR_MIN_" + str(val) for val in tmp[self.optimizer_minimize_reactor_var]]
        if self.optimizer_maximize_reactor_var is not None:
            result = result + ["VAR_MAX_" + str(val) for val in tmp[self.optimizer_maximize_reactor_var]]

        return result


    def plot_tsemo_result(self, result):
        axis_labels = self.util_get_objective_names()

        window = tk.Toplevel(self.window)
        window.wm_title("Izris rezultata")
        window.minsize(800, 600)
        window.grab_set()

        if len(axis_labels) == 2:
            self.util_visualize2DData(window, result['YParetoGP'], axis_labels)
        elif len(axis_labels) >= 3:
            self.util_visualize3DData(window, result['YParetoGP'], axis_labels)


    def write_tsemo_result_to_file(self, result):
        obj_names = self.util_get_objective_names()

        def write_to_file(file_name, dataX, dataY):
            try:
                if not os.path.exists(self.csv_folder):
                    os.makedirs(self.csv_folder)

                tsemo_csv_file = open(file_name, "w")
                header = ",".join(var.name for var in self.reactor_vars) + "," + ",".join(obj for obj in obj_names) + "\n"
                tsemo_csv_file.write(header)

                for row in range(0, len(dataX)):
                    line = ",".join(map(str, dataX[row])) + "," + ",".join(map(str, dataY[row])) + "\n"
                    tsemo_csv_file.write(line)

                tsemo_csv_file.close()

                logtext = f"Kreirana csv datoteka \"{file_name}\" z rezultati optimizacije"
                logger.info(logtext)
                self.add_text_to_log_window(logtext, "white", True)
            except:
                logtext = f"Ne morem odpreti csv datoteke \"{file_name}\""
                logger.critical(logtext)
                messagebox.showerror("Napaka", logtext)
                sys.exit(1)

        fname = self.csv_folder + "pareto_" + self.app_start_time + ".csv"
        write_to_file(fname, result['Xpareto'], result['Ypareto'])

        fname = self.csv_folder + "paretoGP_" + self.app_start_time + ".csv"
        write_to_file(fname, result['XParetoGP'], result['YParetoGP'])


##############################################################################################################
#
# Glavni program
#
##############################################################################################################

if __name__ == "__main__":
    # Preveri, ali aplikacijo poganjamo v 32bit ali 64bit interpreterju
    val = struct.calcsize("P") * 8
    if val != 64:
        print("Aplikacija potrebuje 64-bit Python!")
        sys.exit(1)

    #print(np.show_config())
    #print(scipy.show_config())

    logger = get_master_logger()
    logger.setLevel(logging.INFO)
    logger.info("Zaganjanje FaustoMaster64 aplikacije.")

    root = tk.Tk()
    app = App(root)
    app.start_processing()
    root.mainloop()
    app.shut_down()

    logger.setLevel(logging.INFO)
    logger.info("Zapiranje FaustoMaster64 aplikacije.")
