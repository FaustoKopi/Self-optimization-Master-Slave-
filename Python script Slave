import socket
import selectors
import bisect
import sys
import time
import ctypes
import queue
import struct
import json
import logging
from logging.handlers import RotatingFileHandler
import numpy as np
from ctypes.wintypes import BOOL
from opcua import Client
from random import random

# TODO:
# TODO: TEST TEST TEST TEST TEST
# TODO:
FAKE_LABVISION = False
FAKE_IR = False
FAKE_UPLC = False
CHECK_32_BIT = True


# stanje komunikacije z UPLC sterznikom
STATE_UPLC_IDLE = 1
STATE_UPLC_CONNECT_CLIENT = 2
STATE_UPLC_GET_EXP = 3
STATE_UPLC_GET_SAMPLE_SETTINGS = 4
STATE_UPLC_SCHEDULE_SAMPLE = 5
STATE_UPLC_SCHEDULED_ACTION = 6
STATE_UPLC_GET_SAMPLE = 7
STATE_UPLC_GET_SAMPLE_RESULT = 8
STATE_UPLC_DISCONNECT_CLIENT = 9


UPLC_METHOD_GET_EXPERIMENTS_NODE_NAME = "ns=2; i=1002"
UPLC_METHOD_GET_EXPERIMENT_SAMPLING_SETTINGS_NODE_NAME = "ns=2; i=1009"
UPLC_METHOD_EXPERIMENT_SCHEDULE_SAMPLE_NODE_NAME = "ns=2; i=1010"
UPLC_METHOD_EXPERIMENT_SCHEDULED_ACTION_NODE_NAME = "ns=2; i=1012"
UPLC_METHOD_GET_SAMPLE_NODE_NAME = "ns=2; i=1014"
UPLC_METHOD_GET_SAMPLE_RESULTS_NODE_NAME = "ns=2; i=1015"
UPLC_OBJECT_RPC_NODE_NAME = "ns=2; i=1000"


IR_TREATED_DATA_NODE_NAME = "ns=2;s=Local.iCIR.Probe1.SpectraTreated"
IR_SAMPLE_TIME_NODE_NAME = "ns=2;s=Local.iCIR.Probe1.LastSampleTime"


# kljucne besede v config datoteki
CONFIG_COMMAND_FILE_VER = "CONFIG_FILE_VER"

CONFIG_COMMAND_LOG_LEVEL = "LOG_LEVEL"
CONFIG_COMMAND_SLAVE_URL = "SLAVE_URL"

CONFIG_COMMAND_LABVISION_DLL_FILENAME = "LABVISION_DLL_FILENAME"
CONFIG_COMMAND_LABVISION_PROJECT_NAME = "LABVISION_PROJECT_NAME"

CONFIG_COMMAND_IR_TREATED_DATA_NODE_NAME = "IR_TREATED_DATA_NODE_NAME"
CONFIG_COMMAND_IR_SAMPLE_TIME_NODE_NAME = "IR_SAMPLE_TIME_NODE_NAME"

CONFIG_COMMAND_IR_SERVER_URL = "IR_SERVER_URL"
CONFIG_COMMAND_IR_STATUS_CHECK_INTERVAL = "IR_STATUS_CHECK_INTERVAL"

CONFIG_COMMAND_UPLC_STATUS_CHECK_INTERVAL = "UPLC_STATUS_CHECK_INTERVAL"
CONFIG_COMMAND_UPLC_SERVER_URL = "UPLC_SERVER_URL"
CONFIG_COMMAND_UPLC_SERVER_USERNAME = "UPLC_SERVER_USERNAME"
CONFIG_COMMAND_UPLC_SERVER_PASSWORD = "UPLC_SERVER_PASSWORD"

CONFIG_COMMAND_UPLC_METHOD_GET_EXPERIMENTS_NODE_NAME = "UPLC_METHOD_GET_EXPERIMENTS_NODE_NAME"
CONFIG_COMMAND_UPLC_METHOD_GET_EXPERIMENT_SAMPLING_SETTINGS_NODE_NAME = "UPLC_METHOD_GET_EXPERIMENT_SAMPLING_SETTINGS_NODE_NAME"
CONFIG_COMMAND_UPLC_METHOD_EXPERIMENT_SCHEDULE_SAMPLE_NODE_NAME = "UPLC_METHOD_EXPERIMENT_SCHEDULE_SAMPLE_NODE_NAME"
CONFIG_COMMAND_UPLC_METHOD_EXPERIMENT_SCHEDULED_ACTION_NODE_NAME = "UPLC_METHOD_EXPERIMENT_SCHEDULED_ACTION_NODE_NAME"
CONFIG_COMMAND_UPLC_METHOD_GET_SAMPLE_NODE_NAME = "UPLC_METHOD_GET_SAMPLE_NODE_NAME"
CONFIG_COMMAND_UPLC_METHOD_GET_SAMPLE_RESULTS_NODE_NAME = "UPLC_METHOD_GET_SAMPLE_RESULTS_NODE_NAME"
CONFIG_COMMAND_UPLC_OBJECT_RPC_NODE_NAME = "UPLC_OBJECT_RPC_NODE_NAME"

###############################################################################
#
# POZOR! Kljucne besede protokola morajo biti enake kot v FaustoMaster64
#
###############################################################################

# ukazi za komunikacijo med FaustoMaster in FaustoSlave aplikacijo
PROTOCOL_COMMAND_REG = "REG"
PROTOCOL_COMMAND_SET_IR = "SIR"
PROTOCOL_COMMAND_SET_REACTOR_VARS = "SRV"
PROTOCOL_COMMAND_CHECK_STABILITY = "CHS"
PROTOCOL_COMMAND_START_ANALYSIS = "SAN"
PROTOCOL_COMMAND_CHECK_ANALYSIS = "CAN"

PROTOCOL_ATTR_PKS = "PKS"
PROTOCOL_ATTR_SM = "SM"
PROTOCOL_ATTR_ST = "ST"

PROTOCOL_RESULT_OK = "OK"
PROTOCOL_RESULT_YES = "YES"
PROTOCOL_RESULT_NO = "NO"
PROTOCOL_RESULT_SYNTAX_ERROR = "SER"
PROTOCOL_RESULT_EXEC_ERROR = "EER"
PROTOCOL_RESULT_PROTOCOL_ERROR = "PER"

###############################################################################
###############################################################################
###############################################################################

# privzete nastavitve
DEFAULT_LABVISION_DLL_FILENAME = "C:\\HiTec\\bin\\AppIntf.dll"
DEFAULT_LABVISION_PROJECT_NAME = "FAUSTO_INTERFACE_V2"


DEFAULT_IR_SERVER_URL = "opc.tcp://localhost:62552/iCOpcUaServer"
DEFAULT_IR_STATUS_CHECK_INTERVAL = 10

DEFAULT_UPLC_SERVER_URL = "opc.tcp://dla0237si:48090"
DEFAULT_UPLC_SERVER_USERNAME = ""
DEFAULT_UPLC_SERVER_PASSWORD = ""

DEFAULT_UPLC_STATUS_CHECK_INTERVAL = 10
DEFAULT_UPLC_STATE_MACHINE_UPDATE_INTERVAL = 1

DEFAULT_SLAVE_HOST = "127.0.0.1"
DEFAULT_SLAVE_PORT = 5000






# oznake podatkov, ki jih prejemamo od IR OPC UA Serverja
TAG_X_AXIS = "x_axis"
TAG_Y_AXIS = "y_axis"
TAG_SAMPLE_TIME ="time"

BUF_LEN = 4096
EPS = 0.0001


##############################################################################################################
#
# Logger
#
##############################################################################################################

def get_slave_logger():
    FORMATTER = logging.Formatter(fmt="%(asctime)s - %(levelname)s - %(message)s", datefmt="%Y-%m-%d %H:%M:%S")

    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(FORMATTER)

    file_handler = RotatingFileHandler("slave.log", maxBytes=2000000, backupCount=5)
    file_handler.setFormatter(FORMATTER)

    logger = logging.getLogger("Slave")
    logger.setLevel(logging.INFO)
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    logger.propagate = False
    return logger

##############################################################################################################
#
# Razred "OPCSubHandler"
#
# za sprejemanje podatkov od OPC UA Serverja
#
##############################################################################################################

class OPCSubHandler(object):

    def __init__(self, name_list):
        self.change_queue = queue.Queue()
        self.name_list = name_list

    def datachange_notification(self, node, val, data):
        data_change_obj = {"node": self.name_list[node], "value": val}
        self.change_queue.put(data_change_obj)


##############################################################################################################
#
# Razred "TCPListener"
#
##############################################################################################################

class TCPListener:
    def __init__(self, host, port):
        self.received_requests = {}
        self.generated_responses = {}

        logtext = f"Poslusanje na portu {port}."
        logger.info(logtext)

        self.sel = selectors.DefaultSelector()
        lsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        lsock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        lsock.bind((host, port))
        lsock.listen()
        lsock.setblocking(False)
        self.sel.register(lsock, selectors.EVENT_READ, data=None)

    def get_request(self):
        if len(self.received_requests) > 0:
            pair = self.received_requests.popitem()
            return pair[0], pair[1]
        else:
            return None, None

    def set_response(self, message_id, message_response):
        self.generated_responses.update({message_id: message_response})

    def accept_wrapper(self, sock):
        conn, addr = sock.accept()  # Should be ready to read
        logtext = f"Odprta povezava z {addr}."
        logger.debug(logtext)

        conn.setblocking(False)

        message = SlaveMessage(self.sel, conn, addr)
        self.sel.register(conn, selectors.EVENT_READ, data=message)

    def process_socket_events(self):
        events = self.sel.select(timeout=0.1)
        for key, mask in events:
            if key.data is None:
                self.accept_wrapper(key.fileobj)
            else:
                message = key.data
                try:
                    message.process_events(mask)
                    if message.incoming_text is not None:
                        self.received_requests.update({message.id: message.incoming_text})
                        message.incoming_text = None
                    try:
                        response = self.generated_responses[message.id]
                        self.generated_responses.pop(message.id)
                        message.outgoing_text = response
                    except (KeyError):
                        pass

                except Exception as e:
                    print(e)
                    logtext = f"Napaka pri komunikaciji z {message.addr}."
                    logger.error(logtext)
                    message.close()

    def shut_down(self):
        self.sel.close()


##############################################################################################################
#
# Razred "SlaveMessage"
#
##############################################################################################################

class SlaveMessage:
    def __init__(self, selector, sock, addr):
        self.id = int(time.time() * 1000)
        self.selector = selector
        self.sock = sock
        self.addr = addr

        self.recv_buffer = b""
        self.send_buffer = b""

        self.incoming_encoded_message_len = None
        self.incoming_text = None

        self.outgoing_text = None
        self.outgoing_encoded_message_created = False

    def util_set_selector_events_mask(self, mode):
        """Set selector to listen for events: mode is 'r', 'w', or 'rw'."""
        if mode == "r":
            events = selectors.EVENT_READ
        elif mode == "w":
            events = selectors.EVENT_WRITE
        elif mode == "rw":
            events = selectors.EVENT_READ | selectors.EVENT_WRITE
        else:
            raise ValueError(f"Invalid events mask mode {mode!r}.")
        self.selector.modify(self.sock, events, data=self)

    def util_read_data(self):
        try:
            # Should be ready to read
            data = self.sock.recv(4096)
        except BlockingIOError:
            # Resource temporarily unavailable (errno EWOULDBLOCK)
            pass
        else:
            if data:
                self.recv_buffer += data
            else:
                raise RuntimeError("Peer closed.")

    def util_write_data(self):
        if self.send_buffer:
            logtext = f"Posiljanje {self.send_buffer!r} na {self.addr}."
            logger.debug(logtext)
            try:
                # Should be ready to write
                sent = self.sock.send(self.send_buffer)
            except BlockingIOError:
                # Resource temporarily unavailable (errno EWOULDBLOCK)
                pass
            else:
                self.send_buffer = self.send_buffer[sent:]
                # Close when the buffer is drained. The response has been sent.
                if sent and not self.send_buffer:
                    self.close()


    def process_events(self, mask):
        if mask & selectors.EVENT_READ:
            self.read()
        if mask & selectors.EVENT_WRITE:
            self.write()

    def process_incoming_header(self):
        hdrlen = 2
        if len(self.recv_buffer) >= hdrlen:
            self.incoming_encoded_message_len = struct.unpack(">H", self.recv_buffer[:hdrlen])[0]
            self.recv_buffer = self.recv_buffer[hdrlen:]

    def process_incoming_encoded_message(self):
        msglen = self.incoming_encoded_message_len

        if not len(self.recv_buffer) >= msglen:
            return

        data = self.recv_buffer[:msglen]
        self.recv_buffer = self.recv_buffer[msglen:]
        self.incoming_text = data.decode("utf-8")
        logtext = f"Prejem {self.incoming_text!r} od {self.addr}"
        logger.debug(logtext)

        # Set selector to listen for write events, we're done reading.
        self.util_set_selector_events_mask("w")


    def read(self):
        self.util_read_data()

        if self.incoming_encoded_message_len is None:
            self.process_incoming_header()

        if self.incoming_encoded_message_len is not None:
            if self.incoming_text is None:
                self.process_incoming_encoded_message()


    def write(self):
        if self.outgoing_text is not None:
            if not self.outgoing_encoded_message_created:
                message_hdr = struct.pack(">H", len(self.outgoing_text))
                encoded_message = message_hdr + self.outgoing_text.encode("utf-8")
                self.outgoing_encoded_message_created = True
                self.send_buffer += encoded_message

        self.util_write_data()

    def close(self):
        logtext = f"Zapiranje komunikacije z {self.addr}."
        logger.debug(logtext)
        try:
            self.selector.unregister(self.sock)
        except Exception as e:
            print(
                f"Error: selector.unregister() exception for "
                f"{self.addr}: {e!r}"
            )

        try:
            self.sock.close()
        except OSError as e:
            print(f"Error: socket.close() exception for {self.addr}: {e!r}")
        finally:
            # Delete reference to socket object for garbage collection
            self.sock = None

##############################################################################################################
#
# Razred "CircularBuffer"
#
# krozni buffer za hranjenje zadnjih IR podatkov
#
##############################################################################################################

class CircularBuffer(object):
    def __init__(self, size):
        self.front = 0
        self.rear = 0
        self.data = np.zeros(size + 1)

    def clear(self):
        self.front = 0
        self.rear = 0

    def append(self, value):
        self.data[self.rear] = value
        self.rear = self.rear + 1
        if self.rear == np.size(self.data):
            self.rear = 0

        if self.rear == self.front:
            self.front = self.front + 1
            if self.front == np.size(self.data):
                self.front = 0

    def getsize(self):
        if self.rear >= self.front:
            return self.rear - self.front
        else:
            return np.size(self.data) - self.front + self.rear

    def getall(self):
        if self.rear > self.front:
            return self.data[range(self.front, self.rear)]
        elif self.rear < self.front:
            return self.data[list(range(self.front, np.size(self.data))) + list(range(0, self.rear))]
        else:
            return np.array([])

    def getlast(self):
        if self.front == self.rear:
            return None

        i = self.rear - 1
        if i < 0:
            i = np.size(self.data) - 1
        return self.data[i]

##############################################################################################################
#
# Razred "App"
#
##############################################################################################################

class App:

    #
    # Inicializacija vrednosti atributov razreda
    #

    def __init__(self):

        # dll za labvision
        self.LabVisionDllFileName = ""
        self.ProjectName = ""
        self.LabVisionDll = None
        self.fLabVisionInit = None
        self.fLabVisionClosePool = None
        self.fLabVisionGetProjList = None
        self.fLabVisionGetDPList = None
        self.fLabVisionGetDPValue = None
        self.fLabVisionSetDpValue = None
        self.LabVisionOpenedConnection = False

        # IR
        self.ir_client = None
        self.ir_client_connected =False
        self.ir_server_url = DEFAULT_IR_SERVER_URL
        self.ir_sub_handler = None
        self.ir_subscription = None
        self.ir_sub_datachange_handle = None
        self.ir_treated_data_node_name = IR_TREATED_DATA_NODE_NAME
        self.ir_sample_time_node_name = IR_SAMPLE_TIME_NODE_NAME
        self.ir_target_peaks = None
        self.ir_peaks_data = None
        self.ir_peaks_time = None
        self.ir_x_data = None
        self.ir_y_data = None
        self.ir_last_sample_time = None
        self.ir_slope_measurements = 0
        self.ir_slope_threshold = 0
        self.ir_stabilized = False
        self.ir_status_check_interval = DEFAULT_IR_STATUS_CHECK_INTERVAL
        self.last_ir_status_check_time = 0

        # UPLC
        self.uplc_state = STATE_UPLC_IDLE
        self.uplc_client = None
        self.uplc_client_connected = False
        self.uplc_objRPC = None
        self.uplc_method_get_experiments_node_name = UPLC_METHOD_GET_EXPERIMENTS_NODE_NAME
        self.uplc_method_get_experiment_sampling_settings_node_name = UPLC_METHOD_GET_EXPERIMENT_SAMPLING_SETTINGS_NODE_NAME
        self.uplc_method_experiment_schedule_sample_node_name = UPLC_METHOD_EXPERIMENT_SCHEDULE_SAMPLE_NODE_NAME
        self.uplc_method_experiment_scheduled_action_node_name = UPLC_METHOD_EXPERIMENT_SCHEDULED_ACTION_NODE_NAME
        self.uplc_method_get_sample_node_name = UPLC_METHOD_GET_SAMPLE_NODE_NAME
        self.uplc_method_get_sample_results_node_name = UPLC_METHOD_GET_SAMPLE_RESULTS_NODE_NAME
        self.uplc_object_rpc_node_name = UPLC_OBJECT_RPC_NODE_NAME
        self.uplc_method_GetExperiments = None
        self.uplc_method_GetExperimentSamplingSettings = None
        self.uplc_method_ExperimentScheduleSample = None
        self.uplc_method_ExperimentScheduledAction = None
        self.uplc_method_GetSample = None
        self.uplc_method_GetSampleResults = None
        self.uplc_experiment_id = None
        self.uplc_sample_setting_id = None
        self.uplc_action_id = None
        self.uplc_created_sample_id = None
        self.uplc_sample_completed = False
        self.uplc_sample_result = None
        self.uplc_server_url = DEFAULT_UPLC_SERVER_URL
        self.uplc_server_username = DEFAULT_UPLC_SERVER_USERNAME
        self.uplc_server_password = DEFAULT_UPLC_SERVER_PASSWORD
        self.uplc_status_check_interval = DEFAULT_UPLC_STATUS_CHECK_INTERVAL
        self.last_uplc_status_check_time = 0
        self.uplc_state_machine_update_interval = DEFAULT_UPLC_STATE_MACHINE_UPDATE_INTERVAL
        self.last_uplc_state_machine_update_time = 0
        if FAKE_UPLC:
            self.fake_uplc_sample_completed = False

        # TCP komunikacija s FaustoMaster64
        self.host = DEFAULT_SLAVE_HOST
        self.port = DEFAULT_SLAVE_PORT
        self.listener = None
        self.master_id = 0

    #
    # Branje nastavitev programa
    #

    def read_config_file(self, file_name):

        # verzija skripte se za enkrat ne uporablja...
        config_ver = 1

        try:
            with open(file_name, 'r') as fp:
                for line in fp:
                    if not line.startswith("#") and line.strip():
                        line = line.split("\n")[0]
                        tokens = line.split("=", maxsplit=1)
                        command = tokens[0].strip()
                        if command == CONFIG_COMMAND_LABVISION_DLL_FILENAME:
                            self.LabVisionDllFileName = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_LABVISION_PROJECT_NAME:
                            self.ProjectName = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_IR_SERVER_URL:
                            self.ir_server_url = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_IR_TREATED_DATA_NODE_NAME:
                            self.ir_treated_data_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_IR_SAMPLE_TIME_NODE_NAME:
                            self.ir_sample_time_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_SLAVE_URL:
                            args = tokens[1].split(':')
                            self.host = args[0].strip().replace('"', '')
                            self.port = int(args[1].strip().replace('"', ''))
                        elif command == CONFIG_COMMAND_IR_STATUS_CHECK_INTERVAL:
                            self.ir_status_check_interval = int(tokens[1])
                        elif command == CONFIG_COMMAND_UPLC_STATUS_CHECK_INTERVAL:
                            self.uplc_status_check_interval = int(tokens[1])
                        elif command == CONFIG_COMMAND_UPLC_SERVER_URL:
                            self.uplc_server_url = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_SERVER_USERNAME:
                            self.uplc_server_username = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_SERVER_PASSWORD:
                            self.uplc_server_password = tokens[1].strip().replace('"', '')

                        elif command == CONFIG_COMMAND_UPLC_METHOD_GET_EXPERIMENTS_NODE_NAME:
                            self.uplc_method_get_experiments_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_METHOD_GET_EXPERIMENT_SAMPLING_SETTINGS_NODE_NAME:
                            self.uplc_method_get_experiment_sampling_settings_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_METHOD_EXPERIMENT_SCHEDULE_SAMPLE_NODE_NAME:
                            self.uplc_method_experiment_schedule_sample_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_METHOD_EXPERIMENT_SCHEDULED_ACTION_NODE_NAME:
                            self.uplc_method_experiment_scheduled_action_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_METHOD_GET_SAMPLE_NODE_NAME:
                            self.uplc_method_get_sample_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_METHOD_GET_SAMPLE_RESULTS_NODE_NAME:
                            self.uplc_method_get_sample_results_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_UPLC_OBJECT_RPC_NODE_NAME:
                            self.uplc_object_rpc_node_name = tokens[1].strip().replace('"', '')
                        elif command == CONFIG_COMMAND_LOG_LEVEL:
                            log_level = int(tokens[1])
                            if log_level == 1:
                                logger.setLevel(logging.DEBUG)
                            elif log_level == 2:
                                logger.setLevel(logging.INFO)
                            elif log_level == 3:
                                logger.setLevel(logging.WARNING)
                            elif log_level == 4:
                                logger.setLevel(logging.ERROR)
                            elif log_level == 5:
                                logger.setLevel(logging.CRITICAL)
                            else:
                                logtext = "Vrednost LOG_LEVEL mora biti med 1 in 5."
                                logger.error(logtext)
                        elif command == CONFIG_COMMAND_FILE_VER:
                            config_ver = int(tokens[1])
                            if config_ver != 1:
                                logtext = "Neznana verzija skripte!"
                                logger.critical(logtext)
                                sys.exit(1)
                        else:
                            logtext = f"Neznan ukaz {command} v konfiguracijski datoteki!"
                            logger.critical(logtext)
                            sys.exit(1)
        except FileNotFoundError:
            logtext = f"Ne najdem konfiguracijske datoteke {file_name}!"
            logger.critical(logtext)
            sys.exit(1)
        except IOError:
            logtext = f"Ne morem prebrati konfiguracijske datoteke {file_name}!"
            logger.critical(logtext)
            sys.exit(1)
        except (IndexError, ValueError):
            logtext = f"Napaka v konfiguracijski datoteki (vrstica: {line})!"
            logger.critical(logtext)
            sys.exit(1)


    #
    # Funkcije za upravljanje z LabVisionom
    #

    def load_labvision_dll(self, file_name):
        # TODO:
        # TODO: TEST TEST TEST TEST TEST
        # TODO:
        if FAKE_LABVISION:
            return

        try:
            self.LabVisionDll = ctypes.WinDLL(file_name)

            self.fLabVisionInit = self.LabVisionDll.Init
            self.fLabVisionInit.restype = ctypes.wintypes.BOOL
            self.fLabVisionInit.argtypes = None

            self.fLabVisionClosePool = self.LabVisionDll.ClosePool
            self.fLabVisionClosePool.restype = None
            self.fLabVisionClosePool.argtypes = None

            self.fLabVisionGetProjList = self.LabVisionDll.GetProjList
            self.fLabVisionGetProjList.restype = ctypes.wintypes.LONG
            self.fLabVisionGetProjList.argtypes = [ctypes.wintypes.PCHAR, ctypes.wintypes.PLONG]

            self.fLabVisionGetDPList = self.LabVisionDll.GetDPList
            self.fLabVisionGetDPList.restype = ctypes.wintypes.LONG
            self.fLabVisionGetDPList.argtypes = [ctypes.wintypes.PCHAR, ctypes.wintypes.LONG, ctypes.wintypes.PCHAR,
                                                 ctypes.wintypes.PLONG]

            self.fLabVisionGetDPValue = self.LabVisionDll.GetDPValue
            self.fLabVisionGetDPValue.restype = ctypes.wintypes.LONG
            self.fLabVisionGetDPValue.argtypes = [ctypes.wintypes.PCHAR, ctypes.wintypes.PCHAR, ctypes.wintypes.PCHAR,
                                                  ctypes.wintypes.PLONG]

            self.fLabVisionSetDpValue = self.LabVisionDll.SetDpValue
            self.fLabVisionSetDpValue.restype = ctypes.wintypes.LONG
            self.fLabVisionSetDpValue.argtypes = [ctypes.wintypes.PCHAR, ctypes.wintypes.PCHAR, ctypes.wintypes.PCHAR]
        except OSError as err:
            logtext = f"Napaka pri branju datoteke dll {file_name}!"
            logger.critical(logtext)
            sys.exit(1)


    def connectToPool(self):
        # TODO:
        # TODO: TEST TEST TEST TEST TEST
        # TODO:
        if FAKE_LABVISION:
            return

        if not self.LabVisionOpenedConnection:
            res = self.fLabVisionInit()
            if res != 0:
                self.LabVisionOpenedConnection = True
                logtext = "Povezan na Pool Service"
                logger.info(logtext)
            else:
                logtext = "Povezava na Pool Service ni uspela!"
                logger.error(logtext)

    def disconnectFromPool(self):
        # TODO:
        # TODO: TEST TEST TEST TEST TEST
        # TODO:
        if FAKE_LABVISION:
            return

        if self.LabVisionOpenedConnection:
            self.fLabVisionClosePool()
            self.LabVisionOpenedConnection = False
            # okna ni vec, zato ne moremo tega dodati v log
            logtext = "Zakljucena povezava s Pool Service"
            logger.info(logtext)


    def util_setDataPointValue(self, point_name, point_value):
        # TODO:
        # TODO: TEST TEST TEST TEST TEST
        # TODO:
        if FAKE_LABVISION:
            return 1

        val = str(point_value)
        p = ctypes.create_string_buffer(self.ProjectName.encode())
        d = ctypes.create_string_buffer(point_name.encode())
        s = ctypes.create_string_buffer(val.encode())
        res = self.fLabVisionSetDpValue(p, d, s)
        return res


    def util_getDataPointValue(self, point_name):
        # TODO:
        # TODO: TEST TEST TEST TEST TEST
        # TODO:
        if FAKE_LABVISION:
            return 1, 0

        raw = None
        p = ctypes.create_string_buffer(self.ProjectName.encode())
        d = ctypes.create_string_buffer(point_name.encode())
        l = ctypes.wintypes.LONG(BUF_LEN)
        s = ctypes.create_string_buffer(BUF_LEN)
        res = self.fLabVisionGetDPValue(p, d, s, ctypes.byref(l))
        if res != 0:
            raw = float(s.value.decode())
        return res, raw


    def updateVarSettings(self, point_name, point_value):
        ret_val = False
        res = self.util_setDataPointValue(point_name, point_value)
        if res != 0:
            logtext = f"Nastavljam spremenljivko {point_name} na vrednost {point_value}."
            logger.debug(logtext)
        else:
            logtext = f"Ni uspelo nastavljanje nove vrednosti spremenljivke {point_name}."
            logger.error(logtext)

        res, val = self.util_getDataPointValue(point_name)

        # TODO:
        # TODO: TEST TEST TEST TEST TEST
        # TODO:
        if FAKE_LABVISION:
            val = point_value

        if res != 0:
            if abs(val - point_value) <= EPS:
                logtext = f"LABVISION: Trenutna nastavitev spremenljivke {point_name} je {val}."
                logger.debug(logtext)

                ret_val = True
            else:
                logtext = f"LABVISION: Trenutna nastavitev spremenljivke {point_name} je {val}."
                logger.warning(logtext)

        else:
            logtext = f"Ni uspelo branje trenutne vrednosti spremenljivke {point_name}!"
            logger.error(logtext)

        return ret_val

    #
    # Funkcije za delo z IR
    #

    # Inicializacija IR OPC UA odjemalca
    def initIR(self):
        if FAKE_IR:
            return

        self.ir_client = Client(url=self.ir_server_url)
        self.ir_client_connected = False

    # Funkcija odpre povezavo do IR OPC UA streznika
    def connectToIR(self):
        if FAKE_IR:
            return

        try:
            self.ir_client.connect()
            self.ir_client_connected = True
        except:
            self.ir_client_connected = False
            logtext = "Povezava na IR OPC UA Server ni uspela!"
            logger.error(logtext)

    # Funkcija zapre povezavo do IR OPC UA streznika
    def disconnectFromIR(self):
        if FAKE_IR:
            return

        self.unsubscribeDataChangeIR()

        try:
            if self.ir_client_connected:
                self.ir_client.disconnect()
        except:
            pass

    def subscribeDataChangeIR(self):

        #TODO: premisli, ali je to ok zakomentirati
        #self.clear_ir_measurements()

        node_list = []
        proper_name_list = {}

        tag_x_axis = self.ir_client.get_node(self.ir_treated_data_node_name + ".XAxisDefinition")
        proper_name_list[tag_x_axis] = TAG_X_AXIS
        node_list.append(tag_x_axis)

        tag_y_axis = self.ir_client.get_node(self.ir_treated_data_node_name)
        proper_name_list[tag_y_axis] = TAG_Y_AXIS
        node_list.append(tag_y_axis)

        tag_sample_time = self.ir_client.get_node(self.ir_sample_time_node_name)
        proper_name_list[tag_sample_time] = TAG_SAMPLE_TIME
        node_list.append(tag_sample_time)


        self.ir_sub_handler = OPCSubHandler(proper_name_list)
        self.ir_subscription = self.ir_client.create_subscription(500, self.ir_sub_handler)
        self.ir_sub_datachange_handle = self.ir_subscription.subscribe_data_change(node_list)

        success = True
        for handle in self.ir_sub_datachange_handle:
            if not isinstance(handle, int) and handle.name == "BadNodeIdUnknown":
                success = False

        if not success:
            self.unsubscribeDataChangeIR()

    def unsubscribeDataChangeIR(self):
        try:
            for handle in self.ir_sub_datachange_handle:
                if isinstance(handle, int):
                    self.ir_subscription.unsubscribe(handle)
            if self.ir_subscription is not None:
                self.ir_subscription.delete()
            self.ir_subscription = None
        except:
            pass

    # funkcija nastavi parametre za spremljanje IR podatkov in ugotavljanje stabilnosti
    def set_ir_settings(self, peaks, measurements, threshold):
        self.ir_target_peaks = peaks
        self.ir_slope_measurements = measurements
        self.ir_slope_threshold = threshold
        self.ir_peaks_data = list()
        for i in range(0, len(self.ir_target_peaks)):
            self.ir_peaks_data.append(CircularBuffer(self.ir_slope_measurements))
        self.ir_peaks_time = CircularBuffer(self.ir_slope_measurements)

    # Funkcija poisce vrednost za podano valovno dolzino
    def util_find_value_in_ir_data(self, x):
        low = 0
        high = len(self.ir_x_data) - 1

        i = bisect.bisect_right(self.ir_x_data, x)
        if i:
            low = i - 1

        i = bisect.bisect_left(self.ir_x_data, x)
        if i != len(self.ir_x_data):
            high = i

        return np.interp(x, [self.ir_x_data[low], self.ir_x_data[high]], [self.ir_y_data[low], self.ir_y_data[high]])

    # Funkcija izracuna naklonski kot krivulje prejetih vrednosti
    def util_estimate_slope_in_digrees(self, x, y):

        n = np.size(y)

        # mean of x and y vector
        m_x = np.mean(x)
        m_y = np.mean(y)

        # calculating cross-deviation and deviation about x
        SS_xy = np.sum(y * x) - n * m_y * m_x
        SS_xx = np.sum(x * x) - n * m_x * m_x

        # calculating regression coefficients
        b_1 = SS_xy / SS_xx

        return np.degrees(np.arctan(b_1))

    # Funkcija izbrise vse prejete meritve opazovanih valovnih dolzin
    def clear_ir_measurements(self):
        for i in range(0, len(self.ir_target_peaks)):
            self.ir_peaks_data[i].clear()
        self.ir_peaks_time.clear()

        self.ir_stabilized = False

    # Funkcija prebere prispele podatke od IR OPC UA serverja
    def check_ir_measurements(self):
        if FAKE_IR:
            if self.ir_target_peaks is not None:
                for i in range(0, len(self.ir_target_peaks)):
                    self.ir_peaks_data[i].append(random())

                self.ir_stabilized = True
            return

        try:
            val_obj = self.ir_sub_handler.change_queue.get_nowait()

            if val_obj['node'] == TAG_X_AXIS:
                self.ir_x_data = val_obj['value'].AxisSteps
                self.ir_x_data.reverse()
                logtext = "Prejete x-koordinate IR signala"
                logger.debug(logtext)

            elif val_obj['node'] == TAG_Y_AXIS:
                self.ir_y_data = val_obj['value']
                self.ir_y_data.reverse()

                for i in range(0, len(self.ir_target_peaks)):
                    val = self.util_find_value_in_ir_data(self.ir_target_peaks[i])
                    self.ir_peaks_data[i].append(val)
                    logtext = f"Prejel podatek od IR: x={self.ir_target_peaks[i]}; y={val}"
                    logger.debug(logtext)

            elif val_obj['node'] == TAG_SAMPLE_TIME:
                last_sample_time = val_obj['value']
                if self.ir_last_sample_time is not None:
                    delta = (last_sample_time - self.ir_last_sample_time).total_seconds() / 60
                else:
                    delta = 0.0
                self.ir_last_sample_time = last_sample_time
                self.ir_peaks_time.append(delta)
                logtext = f"Casovna znamka prejetih podatkov od IR: {self.ir_last_sample_time} (delta = {delta})"
                logger.debug(logtext)

                stabilized = False

                if self.ir_peaks_time.getsize() >= self.ir_slope_measurements:
                    stabilized = True
                    for i in range(0, len(self.ir_target_peaks)):
                        if self.ir_peaks_data[i].getsize() >= self.ir_slope_measurements:
                            slope = self.util_estimate_slope_in_digrees(self.ir_peaks_time.getall().cumsum(), self.ir_peaks_data[i].getall())
                            if abs(slope) > self.ir_slope_threshold:
                                stabilized = False
                        else:
                            stabilized = False

                self.ir_stabilized = stabilized

                if stabilized:
                    logtext = "Eksperiment se je stabiliziral!"
                    logger.info(logtext)
        except:
            pass

    # Funkcija periodicno preveri povezavo do IR OPC UA streznika
    def statusCheck_IR(self):
        curTime = time.time()
        if (curTime - self.last_ir_status_check_time) > self.ir_status_check_interval:
            if not self.ir_client_connected:
                self.connectToIR()

            if self.ir_subscription is None and self.ir_client_connected:
                self.subscribeDataChangeIR()

            self.last_ir_status_check_time = curTime

    # Funkcija periodicno preveri povezavo z IR OPC UA straznikom in pobere podatke
    def process_IR(self):
        # preveri, ali se vedno imamo povezavo z IR OPC UA streznikom
        self.statusCheck_IR()
        # preveri, ali imamo nove podatke od IR OPC UA streznika
        self.check_ir_measurements()

    #
    # Funkcije za delo z UPLC
    #

    def uplc_get_experiments(self):
        logtext = "Klicem GetExperiments (UPLC)."
        logger.debug(logtext)

        if FAKE_UPLC:
            resp_json = "[{\"Id\":\"9f08332c-449c-4f55-b2f1-48bf3f8d0e77\",\"Name\":\"Coff_Checkout\",\"CreatedTimeUtc\":\"2023-07-07T07:41:54.714894Z\",\"ExperimentState\":\"Aborted\"},{\"Id\":\"ed0b1e40-00e6-4f8d-b3a2-575040265dcf\",\"Name\":\"aciliranje 1\",\"CreatedTimeUtc\":\"2023-08-21T11:39:06.1427652Z\",\"ExperimentState\":\"Completed\"},{\"Id\":\"d8166275-a1eb-482e-8815-dcba47c5d85f\",\"Name\":\"aciliranje 1 - Copy\",\"CreatedTimeUtc\":\"2023-08-28T10:17:46.6406248Z\",\"ExperimentState\":\"Aborted\"},{\"Id\":\"08bc5140-fe33-4f84-b9d4-3301cabb1050\",\"Name\":\"aciliranje 1 - Copy\",\"CreatedTimeUtc\":\"2023-08-28T10:17:55.2235655Z\",\"ExperimentState\":\"Completed\"},{\"Id\":\"6e87b6e2-56b7-4f4c-a2a3-f66f21abbbae\",\"Name\":\"Test FaustoAI\",\"CreatedTimeUtc\":\"2023-09-29T08:45:30.4251608Z\",\"ExperimentState\":\"Created\"},{\"Id\":\"74d717f5-5599-4286-a686-cb738f927d12\",\"Name\":\"Test FaustoAI\",\"CreatedTimeUtc\":\"2023-09-29T08:46:40.18252Z\",\"ExperimentState\":\"Created\"},{\"Id\":\"fc56d00d-fb1c-4791-aa87-9774263a4285\",\"Name\":\"Test FaustoAI\",\"CreatedTimeUtc\":\"2023-09-29T08:48:06.3937933Z\",\"ExperimentState\":\"Created\"},{\"Id\":\"2ac346a7-425b-4979-820f-7035cab76069\",\"Name\":\"Test FaustoAI\",\"CreatedTimeUtc\":\"2023-09-29T08:49:47.9338152Z\",\"ExperimentState\":\"Created\"},{\"Id\":\"a6b46bee-5ddf-4bf7-9a59-ec2e8ef171ef\",\"Name\":\"Test FaustoAI\",\"CreatedTimeUtc\":\"2023-09-29T08:53:43.4519482Z\",\"ExperimentState\":\"Created\"},{\"Id\":\"77aa1db0-cb60-4ed9-964f-0d5583985fd0\",\"Name\":\"Fausto AI TEST 2\",\"CreatedTimeUtc\":\"2023-09-29T08:58:42.5738154Z\",\"ExperimentState\":\"Created\"},{\"Id\":\"3749992c-0f12-4437-8422-61a9654539e6\",\"Name\":\"aciliranje 1\",\"CreatedTimeUtc\":\"2023-09-29T09:01:52.9148152Z\",\"ExperimentState\":\"Created\"},{\"Id\":\"7da75d93-834a-432e-8044-b666bec6c7bf\",\"Name\":\"Test FaustoAI\",\"CreatedTimeUtc\":\"2023-09-29T09:13:01.6353903Z\",\"ExperimentState\":\"Aborted\"},{\"Id\":\"0a11b222-c7e9-43eb-8800-b778d6b013d3\",\"Name\":\"Test FaustoAI\",\"CreatedTimeUtc\":\"2023-09-29T09:15:57.3982068Z\",\"ExperimentState\":\"Execution\"}]"
        else:
            resp_json = self.uplc_objRPC.call_method(self.uplc_method_GetExperiments, None)

        logtext = f"Prejel odgovor od UPLC: {resp_json}"
        logger.debug(logtext)

        response = json.loads(resp_json)

        self.uplc_experiment_id = None

        # Loop through the list of dictionaries
        for item in response:
            if item.get('ExperimentState') == "Execution":
                self.uplc_experiment_id = item.get('Id')
                break

        logtext = f"Dobljen experiment_id: {self.uplc_experiment_id}"
        logger.debug(logtext)


    def uplc_get_experiment_sample_settings(self):
        logtext = "Klicem GetExperimentSamplingSettings (UPLC)."
        logger.debug(logtext)

        if FAKE_UPLC:
            resp_json = "[{\"Id\":\"3ba99137-32de-4b4f-8785-0aceb5321c48\",\"Name\":\"Start\",\"Description\":\"Start experiment\",\"CanBeScheduled\":false},{\"Id\":\"1d2fc262-68bf-47ad-9dec-dfbea0cb6a04\",\"Name\":\"Finish\",\"Description\":\"No stand-by method specified\",\"CanBeScheduled\":false},{\"Id\":\"33203bf6-4a74-407e-b73e-37e3a2bd307a\",\"Name\":\"DirectInjectionSetting 01\",\"Description\":\"Direct injection at specified times\",\"CanBeScheduled\":true}]"
        else:
            resp_json = self.uplc_objRPC.call_method(self.uplc_method_GetExperimentSamplingSettings, self.uplc_experiment_id)

        logtext = f"Prejel odgovor od UPLC: {resp_json}"
        logger.debug(logtext)

        response = json.loads(resp_json)

        self.uplc_sample_setting_id = None

        # Loop through the list of dictionaries
        for item in response:
            if item.get('CanBeScheduled'):
                self.uplc_sample_setting_id = item.get('Id')
                break

        logtext = f"Dobljen sample_setting_id: {self.uplc_sample_setting_id}"
        logger.debug(logtext)


    def uplc_experiment_schedule_sample(self):
        logtext = "Klicem ExperimentScheduleSample (UPLC)."
        logger.debug(logtext)

        schedule_body = f"{{\"samplingSettingId\": \"{self.uplc_sample_setting_id}\"}}"

        if FAKE_UPLC:
            resp_json = "2"
        else:
            resp_json = self.uplc_objRPC.call_method(self.uplc_method_ExperimentScheduleSample, self.uplc_experiment_id, schedule_body)

        logtext = f"Prejel odgovor od UPLC: {resp_json}"
        logger.debug(logtext)

        response = json.loads(resp_json)
        self.uplc_action_id = response

        logtext = f"Dobljen action_id: {self.uplc_action_id}"
        logger.debug(logtext)


    def uplc_experiment_scheduled_action(self):
        logtext = "Klicem ExperimentScheduledAction (UPLC)."
        logger.debug(logtext)

        if FAKE_UPLC:
            resp_json = "{\"Id\":\"2\",\"StartTime\":\"00.00:14:18.2076579\",\"EndTime\":\"00.00:18:06.4978129\",\"ExpectedStartTime\":\"00.00:14:18.6896857\",\"ExpectedAbsoluteStartTime\":\"2023-09-29T09:30:41.6016983Z\",\"SamplingSettingId\":\"33203bf6-4a74-407e-b73e-37e3a2bd307a\",\"CreatedSampleIds\":[\"cf0edd65-f05e-443b-9ecf-ee3b8fffe4c1\"],\"State\":\"Completed\",\"ProgressInformation\":\"\"}"
        else:
            resp_json = self.uplc_objRPC.call_method(self.uplc_method_ExperimentScheduledAction, self.uplc_experiment_id, f"{self.uplc_action_id}")

        logtext = f"Prejel odgovor od UPLC: {resp_json}"
        logger.debug(logtext)

        response = json.loads(resp_json)

        ids = response.get("CreatedSampleIds")

        if len(ids) > 0:
            self.uplc_created_sample_id = ids[0]
        else:
            self.uplc_created_sample_id = None

        logtext = f"Dobljen created_sample_id: {self.uplc_created_sample_id}"
        logger.debug(logtext)


    def uplc_get_sample(self):
        logtext = "Klicem GetSample (UPLC)."
        logger.debug(logtext)

        if FAKE_UPLC:
            if self.fake_uplc_sample_completed:
                resp_json = "{\"Id\":\"ab81e2b0-1c71-4bc7-ba36-25662d7b83ef\",\"Name\":\"Sample-2\",\"SampleState\":\"Completed\",\"SampleStateMessage\":\"\",\"Location\":\"D1F-A1\",\"SamplingSettingGuid\":\"33203bf6-4a74-407e-b73e-37e3a2bd307a\",\"SamplingTime\":\"00.00:30:52.1139874\"}"
            else:
                resp_json = "{\"Id\":\"ab81e2b0-1c71-4bc7-ba36-25662d7b83ef\",\"Name\":\"Sample-2\",\"SampleState\":\"Analysis\",\"SampleStateMessage\":\"\",\"Location\":\"D1F-A1\",\"SamplingSettingGuid\":\"33203bf6-4a74-407e-b73e-37e3a2bd307a\",\"SamplingTime\":null}"

            self.fake_uplc_sample_completed = not self.fake_uplc_sample_completed
        else:
            resp_json = self.uplc_objRPC.call_method(self.uplc_method_GetSample, self.uplc_created_sample_id)

        logtext = f"Prejel odgovor od UPLC: {resp_json}"
        logger.debug(logtext)

        response = json.loads(resp_json)

        state = response.get("SampleState")
        self.uplc_sample_completed = state == "Completed"

        if self.uplc_sample_completed:
            logtext = f"Rezultati za vzorec z id-jem {self.uplc_created_sample_id} so na voljo."
        else:
            logtext = f"Rezultati za vzorec z id-jem {self.uplc_created_sample_id} niso na voljo."

        logger.debug(logtext)


    def util_sample_results_to_string(self, sample_peaks):
        result = ""
        if len(sample_peaks) > 0:
            result = "#".join(str(peak.get("RetentionTime") or 0) + ":" + str(peak.get("AreaPercent") or 0) + ":" + str(peak.get("CorrectedConcentration") or 0) for peak in sample_peaks)
            #result = "#".join(str(peak.get("RetentionTime") or 0) + ":" + str(peak.get("CorrectedArea") or 0) + ":" + str(peak.get("CorrectedConcentration") or 0) for peak in sample_peaks)
        return result



    def uplc_get_sample_result(self):
        logtext = "Klicem GetSampleResult (UPLC)."
        logger.debug(logtext)

        if FAKE_UPLC:
            resp_json = "[{\"SampleName\":\"Sample-1\",\"SampleGuid\":\"cf0edd65-f05e-443b-9ecf-ee3b8fffe4c1\",\"AnalyticalMethodSetName\":\"MethodSet 1\",\"Peaks\":[{\"CompoundName\":\"\",\"SignalName\":\"DAD1A\",\"RetentionTime\":0.20999879058499,\"AreaPercent\":45.3039955539497,\"CorrectedArea\":1702.5092720008,\"CorrectedAmount\":null,\"CorrectedConcentration\":null,\"RawArea\":1702.5092720008,\"RawAmount\":null,\"RawConcentration\":null,\"Height\":133.943783803879,\"HeightPercent\":48.4613123247132,\"DilutionFactor\":null,\"AmountUnit\":null,\"ConcentrationUnit\":null,\"CustomCalculationResults\":null},{\"CompoundName\":\"\",\"SignalName\":\"DAD1A\",\"RetentionTime\":0.458712690803886,\"AreaPercent\":54.6960044460503,\"CorrectedArea\":2055.45788119077,\"CorrectedAmount\":null,\"CorrectedConcentration\":null,\"RawArea\":2055.45788119077,\"RawAmount\":null,\"RawConcentration\":null,\"Height\":142.449440767494,\"HeightPercent\":51.5386876752868,\"DilutionFactor\":null,\"AmountUnit\":null,\"ConcentrationUnit\":null,\"CustomCalculationResults\":null}],\"CustomCalculationResults\":null}]"
        else:
            resp_json = self.uplc_objRPC.call_method(self.uplc_method_GetSampleResults, self.uplc_created_sample_id)

        logtext = f"Prejel odgovor od UPLC: {resp_json}"
        logger.debug(logtext)

        resp = json.loads(resp_json)

        if len(resp) == 0:
            self.uplc_sample_result = "0"
            logtext = "Prejet vzorec je prazen (UPLC)."
            logger.info(logtext)
        else:
            sample_peaks = resp[0].get("Peaks")
            self.uplc_sample_result = self.util_sample_results_to_string(sample_peaks)

            num_peaks = len(sample_peaks)
            logtext = f"Prejeto stevilo vrhov: {num_peaks} (UPLC)."
            logger.info(logtext)

            for peak in range(num_peaks):
                retentionTime = sample_peaks[peak].get("RetentionTime")
                correctedArea = sample_peaks[peak].get("CorrectedArea")
                areaPercent = sample_peaks[peak].get("AreaPercent")
                correctedConcentration = sample_peaks[peak].get("CorrectedConcentration")
                logtext = f"Podatki za vrh {peak+1} (UPLC): Retention time={retentionTime}, Area percent={areaPercent}, Corrected area={correctedArea}, Corrected concentration={correctedConcentration}"
                logger.info(logtext)


    def uplc_start_analysis(self):
        self.uplc_state = STATE_UPLC_GET_EXP
        self.uplc_experiment_id = None
        self.uplc_sample_setting_id = None
        self.uplc_action_id = None
        self.uplc_created_sample_id = None
        self.uplc_sample_completed = False
        self.uplc_sample_result = None

    def uplc_update_state_machine(self):
        curTime = time.time()
        if (curTime - self.last_uplc_state_machine_update_time) > self.uplc_state_machine_update_interval:

            if self.uplc_state == STATE_UPLC_IDLE:
                pass
            elif self.uplc_state == STATE_UPLC_GET_EXP:
                self.uplc_get_experiments()
                self.uplc_state = STATE_UPLC_GET_SAMPLE_SETTINGS
            elif self.uplc_state == STATE_UPLC_GET_SAMPLE_SETTINGS:
                self.uplc_get_experiment_sample_settings()
                self.uplc_state = STATE_UPLC_SCHEDULE_SAMPLE
            elif self.uplc_state == STATE_UPLC_SCHEDULE_SAMPLE:
                self.uplc_experiment_schedule_sample()
                self.uplc_state = STATE_UPLC_SCHEDULED_ACTION
            elif self.uplc_state == STATE_UPLC_SCHEDULED_ACTION:
                self.uplc_experiment_scheduled_action()
                if self.uplc_created_sample_id is not None:
                    self.uplc_state = STATE_UPLC_GET_SAMPLE
            elif self.uplc_state == STATE_UPLC_GET_SAMPLE:
                self.uplc_get_sample()
                if self.uplc_sample_completed:
                    self.uplc_state = STATE_UPLC_GET_SAMPLE_RESULT
            elif self.uplc_state == STATE_UPLC_GET_SAMPLE_RESULT:
                self.uplc_get_sample_result()
                self.uplc_state = STATE_UPLC_IDLE

            self.last_uplc_state_machine_update_time = curTime

    # Inicializacija UPLC OPC UA odjemalca
    def initUPLC(self):
        if FAKE_UPLC:
            return

        self.uplc_client = Client(url=self.uplc_server_url)
        self.uplc_client.set_user(self.uplc_server_username)
        self.uplc_client.set_password(self.uplc_server_password)
        self.uplc_client_connected = False

    # Funkcija odpre povezavo do UPLC OPC UA streznika
    def connectToUPLC(self):
        if FAKE_UPLC:
            return

        try:
            self.uplc_client.connect()
            self.uplc_method_GetExperiments = self.uplc_client.get_node(UPLC_METHOD_GET_EXPERIMENTS_NODE_NAME)
            self.uplc_method_GetExperimentSamplingSettings = self.uplc_client.get_node(UPLC_METHOD_GET_EXPERIMENT_SAMPLING_SETTINGS_NODE_NAME)
            self.uplc_method_ExperimentScheduleSample = self.uplc_client.get_node(UPLC_METHOD_EXPERIMENT_SCHEDULE_SAMPLE_NODE_NAME)
            self.uplc_method_ExperimentScheduledAction = self.uplc_client.get_node(UPLC_METHOD_EXPERIMENT_SCHEDULED_ACTION_NODE_NAME)
            self.uplc_method_GetSample = self.uplc_client.get_node(UPLC_METHOD_GET_SAMPLE_NODE_NAME)
            self.uplc_method_GetSampleResults = self.uplc_client.get_node(UPLC_METHOD_GET_SAMPLE_RESULTS_NODE_NAME)
            self.uplc_objRPC = self.uplc_client.get_node(UPLC_OBJECT_RPC_NODE_NAME)
            self.uplc_client_connected = True
        except:
            self.uplc_client_connected = False
            logtext = "Povezava na UPLC OPC UA Server ni uspela!"
            logger.error(logtext)

    # Funkcija zapre povezavo do UPLC OPC UA streznika
    def disconnectFromUPLC(self):
        if FAKE_UPLC:
            return

        try:
            if self.uplc_client_connected:
                self.uplc_client.disconnect()
        except:
            pass

        # Funkcija periodicno preveri povezavo z IR OPC UA straznikom in pobere podatke

    # Funkcija periodicno preveri povezavo do UPLC OPC UA streznika
    def statusCheck_UPLC(self):
        curTime = time.time()
        if (curTime - self.last_uplc_status_check_time) > self.uplc_status_check_interval:
            if not self.uplc_client_connected:
                self.connectToUPLC()

            self.last_uplc_status_check_time = curTime

    def process_UPLC(self):
        # preveri, ali se vedno imamo povezavo z UPLC OPC UA streznikom
        self.statusCheck_UPLC()
        # preveri, ali imamo nove podatke od IR OPC UA streznika
        self.uplc_update_state_machine()


    #
    # Funkcija za parsanje in izvajanje prejetih ukazov, ter pripravo odgovora
    #

    def parse_request(self, id, request):
        tokens = request.split("#")

        request_num = None
        master_id = None
        command = None

        try:
            params = tokens[0].split(":")
            request_num = int(params[0])
            master_id = int(params[1])
            command = params[2]

            if command == PROTOCOL_COMMAND_REG:
                self.master_id = master_id
                #TODO inicializacija vseh nastavitev ir
                self.listener.set_response(id, f"{request_num}:{master_id}:{PROTOCOL_RESULT_OK}")
                logtext = f"Registracija FaustoMaster64 aplikacije (id={master_id})."
                logger.info(logtext)
            elif master_id != self.master_id:
                self.listener.set_response(id, f"{request_num}:{master_id}:{PROTOCOL_RESULT_PROTOCOL_ERROR}")
                logtext = f"Prejem ukaza od neregistrirane FaustoMaster64 aplikacije (id={master_id})."
                logger.warning(logtext)
            elif command == PROTOCOL_COMMAND_SET_IR:
                cur_ir_target_peaks = None
                cur_slope_measurements = None
                cur_slope_threshold = None

                params = tokens[1].split(":")
                if params[0] == PROTOCOL_ATTR_PKS:
                    cur_ir_target_peaks = [float(x) for x in params[1].split(',')]
                params = tokens[2].split(":")
                if params[0] == PROTOCOL_ATTR_SM:
                    cur_slope_measurements = int(params[1])
                params = tokens[3].split(":")
                if params[0] == PROTOCOL_ATTR_ST:
                    cur_slope_threshold = float(params[1])

                if cur_ir_target_peaks is not None and cur_slope_measurements is not None and cur_slope_threshold is not None:
                    self.set_ir_settings(cur_ir_target_peaks, cur_slope_measurements, cur_slope_threshold)
                    self.listener.set_response(id, f"{request_num}:{master_id}:{PROTOCOL_RESULT_OK}")
                    logtext = f"Uspesno nastavljeni parametri za spremljanje IR signala."
                    logger.info(logtext)
                else:
                    self.listener.set_response(id, f"{request_num}:{master_id}:{PROTOCOL_RESULT_PROTOCOL_ERROR}")
                    logtext = f"Manjkajoce vrednosti pri nastavljanju parametrov za spremljanje IR signala!"
                    logger.warning(logtext)

            elif command == PROTOCOL_COMMAND_SET_REACTOR_VARS:
                self.clear_ir_measurements()

                def util_split(el):
                    var = el.split(":")
                    return var[0], float(var[1])

                elements = [util_split(el) for el in tokens[1:]]
                ret_vals = [self.updateVarSettings(el[0], el[1]) for el in elements]
                if all(ret_vals):
                    self.listener.set_response(id, f"{request_num}:{master_id}:{PROTOCOL_RESULT_OK}")
                    logtext = "Uspesno nastavljeni parametri eksperimenta!"
                    logger.info(logtext)
                else:
                    self.listener.set_response(id, f"{request_num}:{master_id}:{PROTOCOL_RESULT_EXEC_ERROR}")
                    logtext = "Vsaj eden izmed parametrov eksperimenta ni uspesno nastavljen!"
                    logger.warning(logtext)

            elif command == PROTOCOL_COMMAND_CHECK_STABILITY:
                if self.ir_stabilized:
                    result = PROTOCOL_RESULT_YES
                    logtext = "Odgovor na poizvedbo: IR signal je stabiliziran"
                else:
                    result = PROTOCOL_RESULT_NO
                    logtext = "Odgovor na poizvedbo: IR signal ni stabiliziran"

                for i in range(0, len(self.ir_target_peaks)):
                    result += ":"
                    val = self.ir_peaks_data[i].getlast()
                    result += str(val)
                self.listener.set_response(id, f"{request_num}:{master_id}:{result}")
                logger.info(logtext)

            elif command == PROTOCOL_COMMAND_START_ANALYSIS:
                self.uplc_start_analysis()
                result = PROTOCOL_RESULT_OK
                logtext = "Sprejeta zahteva za analizo eksperimenta"
                self.listener.set_response(id, f"{request_num}:{master_id}:{result}")
                logger.info(logtext)

            elif command == PROTOCOL_COMMAND_CHECK_ANALYSIS:
                if self.uplc_sample_result:
                    result = PROTOCOL_RESULT_YES + "#" + self.uplc_sample_result
                    self.listener.set_response(id, f"{request_num}:{master_id}:{result}")
                    logtext = "Odgovor na poizvedbo: Analiza eksperimenta je zakljucena"
                    logger.info(logtext)
                else:
                    result = PROTOCOL_RESULT_NO
                    self.listener.set_response(id, f"{request_num}:{master_id}:{result}")
                    logtext = "Odgovor na poizvedbo: Analiza eksperimenta ni zakljucena"
                    logger.info(logtext)

        except (IndexError, ValueError):
            self.listener.set_response(id, f"{request_num}:{master_id}:{PROTOCOL_RESULT_SYNTAX_ERROR}")
            logtext = f"Napaka v zgradbi prejetega ukaza: {request}"
            logger.warning(logtext)

    #
    # Funkcija za periodicno obdelavo vseh dogodkov
    #
    def do_processing(self):
        # najprej obdelaj tcp dogodke
        self.listener.process_socket_events()
        conn_id, request = self.listener.get_request()

        # preveri, ali smo prejeli zahtevo od FaustoMaster64 aplikacije
        if request is not None:
            self.parse_request(conn_id, request)

        # obdelaj IR dogodke
        self.process_IR()
        self.process_UPLC()

    def start_processing(self):
        self.read_config_file("config_slave.txt")
        self.load_labvision_dll(self.LabVisionDllFileName)
        self.connectToPool()
        self.initIR()
        self.connectToIR()
        self.initUPLC()
        self.connectToUPLC()
        self.listener = TCPListener(self.host, self.port)

    def shut_down(self):
        self.listener.shut_down()
        self.disconnectFromIR()
        self.disconnectFromUPLC()
        self.disconnectFromPool()

##############################################################################################################
#
# Glavni program
#
##############################################################################################################

if __name__ == "__main__":

# TODO:
# TODO: TEST TEST TEST TEST TEST
# TODO:
    if CHECK_32_BIT:
        # Preveri, ali aplikacijo poganjamo v 32bit ali 64bit interpreterju
        val = struct.calcsize("P") * 8
        if val != 32:
            print("Aplikacija potrebuje 32-bit Python!")
            sys.exit(1)

    logger = get_slave_logger()
    logger.setLevel(logging.INFO)
    logger.info("Zaganjanje FaustoSlave aplikacije.")

    app = App()
    app.start_processing()
    try:
        while True:
            app.do_processing()
            time.sleep(0.1)
    except KeyboardInterrupt:
        print("Caught keyboard interrupt, exiting")
    finally:
        app.shut_down()

    logger.setLevel(logging.INFO)
    logger.info("Zapiranje FaustoSlave aplikacije.")
